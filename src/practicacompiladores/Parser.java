
//----------------------------------------------------
// The following code was generated by CUP v0.11b 20160615 (GIT 4ac7450)
//----------------------------------------------------

package practicacompiladores;

import java_cup.runtime.*;
import Symbols.*;
import SymbolsTable.*;
import Exceptions.*;
import java.io.FileReader;
import java.util.ArrayList;
import SymbolsTable.TypeDescription;
import SymbolsTable.TypeDescription.CONTENT_DESCRIPTION;
import SymbolsTable.TypeDescription.BASIC_SUBJACENT_TYPE;
import digraph.*;
import BackendCompiler.*;
import BackendCompiler.Quadruple.OpCode;
import BackendCompiler.Operator.TypeOperator;
import java.util.UUID;
import java.util.Stack;
import java_cup.runtime.XMLElement;

/** CUP v0.11b 20160615 (GIT 4ac7450) generated parser.
  */
@SuppressWarnings({"rawtypes"})
public class Parser extends java_cup.runtime.lr_parser {

 public final Class getSymbolContainer() {
    return ParserSym.class;
}

  /** Default constructor. */
  @Deprecated
  public Parser() {super();}

  /** Constructor which sets the default scanner. */
  @Deprecated
  public Parser(java_cup.runtime.Scanner s) {super(s);}

  /** Constructor which sets the default scanner. */
  public Parser(java_cup.runtime.Scanner s, java_cup.runtime.SymbolFactory sf) {super(s,sf);}

  /** Production table. */
  protected static final short _production_table[][] = 
    unpackFromStrings(new String[] {
    "\000\116\000\002\002\004\000\002\002\005\000\002\003" +
    "\002\000\002\004\007\000\002\005\004\000\002\005\003" +
    "\000\002\006\003\000\002\006\003\000\002\006\003\000" +
    "\002\006\003\000\002\006\003\000\002\006\003\000\002" +
    "\006\003\000\002\006\003\000\002\034\005\000\002\034" +
    "\011\000\002\035\003\000\002\035\002\000\002\037\006" +
    "\000\002\007\005\000\002\010\005\000\002\010\005\000" +
    "\002\011\005\000\002\011\004\000\002\011\003\000\002" +
    "\012\003\000\002\012\002\000\002\036\003\000\002\036" +
    "\003\000\002\036\004\000\002\036\003\000\002\036\003" +
    "\000\002\036\005\000\002\036\003\000\002\036\003\000" +
    "\002\040\007\000\002\030\005\000\002\031\005\000\002" +
    "\031\003\000\002\032\003\000\002\032\005\000\002\032" +
    "\003\000\002\032\003\000\002\033\007\000\002\013\003" +
    "\000\002\014\002\000\002\015\002\000\002\016\003\000" +
    "\002\017\003\000\002\020\014\000\002\021\015\000\002" +
    "\021\002\000\002\022\012\000\002\022\003\000\002\023" +
    "\004\000\002\024\015\000\002\024\007\000\002\025\012" +
    "\000\002\025\003\000\002\051\013\000\002\052\016\000" +
    "\002\026\002\000\002\027\002\000\002\041\013\000\002" +
    "\041\002\000\002\042\007\000\002\043\003\000\002\043" +
    "\002\000\002\044\007\000\002\044\005\000\002\045\003" +
    "\000\002\045\002\000\002\046\005\000\002\046\002\000" +
    "\002\047\006\000\002\050\005\000\002\050\003\000\002" +
    "\053\002" });

  /** Access to production table. */
  public short[][] production_table() {return _production_table;}

  /** Parse-action table. */
  protected static final short[][] _action_table = 
    unpackFromStrings(new String[] {
    "\000\304\000\006\016\uffff\021\uffff\001\002\000\006\016" +
    "\uffc1\021\uffc1\001\002\000\004\002\006\001\002\000\004" +
    "\002\001\001\002\000\006\016\010\021\011\001\002\000" +
    "\004\037\273\001\002\000\004\024\267\001\002\000\004" +
    "\025\014\001\002\000\004\002\000\001\002\000\004\026" +
    "\015\001\002\000\024\005\uffc4\010\uffc4\014\uffc4\015\uffc4" +
    "\017\uffc4\020\uffc4\023\uffc4\027\uffc4\037\uffc4\001\002\000" +
    "\024\005\026\010\030\014\040\015\037\017\uffba\020\031" +
    "\023\020\027\uffba\037\027\001\002\000\026\005\ufff4\010" +
    "\ufff4\012\ufff4\014\ufff4\015\ufff4\017\ufff4\020\ufff4\023\ufff4" +
    "\027\ufff4\037\ufff4\001\002\000\004\024\263\001\002\000" +
    "\026\005\ufff8\010\ufff8\012\ufff8\014\ufff8\015\ufff8\017\ufff8" +
    "\020\ufff8\023\ufff8\027\ufff8\037\ufff8\001\002\000\026\005" +
    "\ufff9\010\ufff9\012\ufff9\014\ufff9\015\ufff9\017\ufff9\020\ufff9" +
    "\023\ufff9\027\ufff9\037\ufff9\001\002\000\010\011\240\013" +
    "\242\027\241\001\002\000\026\005\ufffb\010\ufffb\012\ufffb" +
    "\014\ufffb\015\ufffb\017\ufffb\020\ufffb\023\ufffb\027\ufffb\037" +
    "\ufffb\001\002\000\026\005\ufffc\010\ufffc\012\ufffc\014\ufffc" +
    "\015\ufffc\017\ufffc\020\ufffc\023\ufffc\027\ufffc\037\ufffc\001" +
    "\002\000\004\024\127\001\002\000\012\004\ufff0\030\146" +
    "\032\161\033\145\001\002\000\004\024\177\001\002\000" +
    "\004\024\171\001\002\000\026\005\ufff6\010\ufff6\012\ufff6" +
    "\014\ufff6\015\ufff6\017\ufff6\020\ufff6\023\ufff6\027\ufff6\037" +
    "\ufff6\001\002\000\026\005\ufff7\010\ufff7\012\ufff7\014\ufff7" +
    "\015\ufff7\017\ufff7\020\ufff7\023\ufff7\027\ufff7\037\ufff7\001" +
    "\002\000\024\005\026\010\030\014\040\015\037\017\uffbb" +
    "\020\031\023\020\027\uffbb\037\027\001\002\000\026\005" +
    "\ufff5\010\ufff5\012\ufff5\014\ufff5\015\ufff5\017\ufff5\020\ufff5" +
    "\023\ufff5\027\ufff5\037\ufff5\001\002\000\026\005\ufffa\010" +
    "\ufffa\012\ufffa\014\ufffa\015\ufffa\017\ufffa\020\ufffa\023\ufffa" +
    "\027\ufffa\037\ufffa\001\002\000\004\024\uffc4\001\002\000" +
    "\004\024\uffb4\001\002\000\006\017\043\027\uffb8\001\002" +
    "\000\004\027\uffc3\001\002\000\022\020\031\022\055\024" +
    "\056\036\044\037\046\040\uffe7\041\054\042\047\001\002" +
    "\000\004\040\uffe8\001\002\000\004\040\121\001\002\000" +
    "\014\025\uffe0\027\uffe0\030\uffe0\031\uffe0\034\uffe0\001\002" +
    "\000\014\025\uffe2\027\uffe2\030\uffe2\031\uffe2\034\uffe2\001" +
    "\002\000\004\031\120\001\002\000\014\025\uffe6\027\uffe6" +
    "\030\uffe6\031\uffe6\034\uffe6\001\002\000\014\025\uffe5\027" +
    "\uffe5\030\uffe5\031\uffe5\034\uffe5\001\002\000\014\025\uffdf" +
    "\027\uffdf\030\uffdf\031\uffdf\034\uffdf\001\002\000\014\025" +
    "\uffe3\027\uffe3\030\uffe3\031\uffe3\034\uffe3\001\002\000\004" +
    "\024\116\001\002\000\016\024\070\026\065\036\044\037" +
    "\061\040\uffe7\042\063\001\002\000\006\025\uffd7\035\uffd7" +
    "\001\002\000\004\040\115\001\002\000\010\025\uffd8\035" +
    "\uffd8\036\uffe9\001\002\000\006\025\114\035\101\001\002" +
    "\000\006\025\uffda\035\uffda\001\002\000\004\036\112\001" +
    "\002\000\022\020\031\022\055\024\056\036\044\037\046" +
    "\040\uffe7\041\054\042\047\001\002\000\006\025\uffdb\035" +
    "\uffdb\001\002\000\006\025\105\036\074\001\002\000\016" +
    "\024\070\026\065\036\044\037\061\040\uffe7\042\063\001" +
    "\002\000\006\025\100\035\101\001\002\000\006\025\073" +
    "\036\074\001\002\000\006\025\uffeb\036\uffeb\001\002\000" +
    "\012\024\076\036\044\037\077\040\uffe7\001\002\000\006" +
    "\025\uffed\036\uffed\001\002\000\012\024\076\036\044\037" +
    "\077\040\uffe7\001\002\000\006\025\uffe9\036\uffe9\001\002" +
    "\000\006\025\uffd9\035\uffd9\001\002\000\012\024\102\026" +
    "\065\037\104\042\063\001\002\000\012\024\102\026\065" +
    "\037\104\042\063\001\002\000\006\025\uffdc\035\uffdc\001" +
    "\002\000\006\025\uffd8\035\uffd8\001\002\000\014\025\uffee" +
    "\027\uffee\030\uffee\031\uffee\034\uffee\001\002\000\004\034" +
    "\107\001\002\000\022\020\031\022\055\024\056\036\044" +
    "\037\046\040\uffe7\041\054\042\047\001\002\000\004\027" +
    "\111\001\002\000\006\025\uffd6\035\uffd6\001\002\000\012" +
    "\024\076\036\044\037\077\040\uffe7\001\002\000\006\025" +
    "\uffec\036\uffec\001\002\000\016\025\uffdd\026\uffdd\027\uffdd" +
    "\030\uffdd\031\uffdd\034\uffdd\001\002\000\006\025\uffea\036" +
    "\uffea\001\002\000\004\025\117\001\002\000\014\025\uffe1" +
    "\027\uffe1\030\uffe1\031\uffe1\034\uffe1\001\002\000\004\027" +
    "\uffb9\001\002\000\014\025\uffe4\027\uffe4\030\uffe4\031\uffe4" +
    "\034\uffe4\001\002\000\004\027\123\001\002\000\006\016" +
    "\uffc2\021\uffc2\001\002\000\004\024\127\001\002\000\004" +
    "\024\uffd1\001\002\000\004\026\uffd5\001\002\000\012\024" +
    "\102\026\065\037\104\042\063\001\002\000\004\026\131" +
    "\001\002\000\020\005\uffc4\010\uffc4\014\uffc4\015\uffc4\020" +
    "\uffc4\023\uffc4\037\uffc4\001\002\000\020\005\uffd4\010\uffd4" +
    "\014\uffd4\015\uffd4\020\uffd4\023\uffd4\037\uffd4\001\002\000" +
    "\020\005\026\010\030\014\040\015\037\020\031\023\020" +
    "\037\027\001\002\000\022\005\026\010\030\014\040\015" +
    "\037\020\031\023\020\027\uffc3\037\027\001\002\000\004" +
    "\027\137\001\002\000\026\005\ufffd\010\ufffd\012\ufffd\014" +
    "\ufffd\015\ufffd\017\ufffd\020\ufffd\023\ufffd\027\ufffd\037\ufffd" +
    "\001\002\000\026\005\uffc6\010\uffc6\012\uffc6\014\uffc6\015" +
    "\uffc6\017\uffc6\020\uffc6\023\uffc6\027\uffc6\037\uffc6\001\002" +
    "\000\004\024\141\001\002\000\004\037\143\001\002\000" +
    "\004\024\127\001\002\000\010\004\ufff0\030\146\033\145" +
    "\001\002\000\004\004\150\001\002\000\004\004\ufff1\001" +
    "\002\000\004\037\143\001\002\000\030\005\ufff3\010\ufff3" +
    "\012\ufff3\014\ufff3\015\ufff3\017\ufff3\020\ufff3\023\ufff3\024" +
    "\ufff3\027\ufff3\037\ufff3\001\002\000\004\037\151\001\002" +
    "\000\004\032\152\001\002\000\022\020\031\022\055\024" +
    "\056\036\044\037\046\040\uffe7\041\054\042\047\001\002" +
    "\000\004\031\154\001\002\000\030\005\ufff2\010\ufff2\012" +
    "\ufff2\014\ufff2\015\ufff2\017\ufff2\020\ufff2\023\ufff2\024\ufff2" +
    "\027\ufff2\037\ufff2\001\002\000\004\031\156\001\002\000" +
    "\004\037\160\001\002\000\004\025\164\001\002\000\004" +
    "\032\161\001\002\000\022\020\031\022\055\024\056\036" +
    "\044\037\046\040\uffe7\041\054\042\047\001\002\000\004" +
    "\031\163\001\002\000\030\005\uffef\010\uffef\012\uffef\014" +
    "\uffef\015\uffef\017\uffef\020\uffef\023\uffef\025\uffef\027\uffef" +
    "\037\uffef\001\002\000\004\026\165\001\002\000\020\005" +
    "\026\010\030\014\040\015\037\020\031\023\020\037\027" +
    "\001\002\000\022\005\026\010\030\014\040\015\037\020" +
    "\031\023\020\027\uffc3\037\027\001\002\000\004\027\170" +
    "\001\002\000\026\005\uffc5\010\uffc5\012\uffc5\014\uffc5\015" +
    "\uffc5\017\uffc5\020\uffc5\023\uffc5\027\uffc5\037\uffc5\001\002" +
    "\000\004\037\173\001\002\000\006\025\174\030\175\001" +
    "\002\000\006\025\uffb5\030\uffb5\001\002\000\036\005\uffb7" +
    "\010\uffb7\012\uffb7\014\uffb7\015\uffb7\017\uffb7\020\uffb7\023" +
    "\uffb7\025\uffb7\027\uffb7\030\uffb7\031\uffb7\034\uffb7\037\uffb7" +
    "\001\002\000\022\020\031\022\055\024\056\036\044\037" +
    "\046\040\uffe7\041\054\042\047\001\002\000\006\025\uffb6" +
    "\030\uffb6\001\002\000\022\020\031\022\055\024\056\036" +
    "\044\037\046\040\uffe7\041\054\042\047\001\002\000\004" +
    "\025\201\001\002\000\004\026\202\001\002\000\010\011" +
    "\uffc9\013\uffc9\027\uffc9\001\002\000\004\026\204\001\002" +
    "\000\020\005\uffc4\010\uffc4\014\uffc4\015\uffc4\020\uffc4\023" +
    "\uffc4\037\uffc4\001\002\000\020\005\uffd4\010\uffd4\014\uffd4" +
    "\015\uffd4\020\uffd4\023\uffd4\037\uffd4\001\002\000\020\005" +
    "\026\010\030\014\040\015\037\020\031\023\020\037\027" +
    "\001\002\000\022\005\026\010\030\014\040\015\037\020" +
    "\031\023\020\027\uffc3\037\027\001\002\000\004\027\211" +
    "\001\002\000\032\005\uffce\006\uffce\007\uffce\010\uffce\012" +
    "\uffce\014\uffce\015\uffce\017\uffce\020\uffce\023\uffce\027\uffce" +
    "\037\uffce\001\002\000\032\005\uffd3\006\uffb4\007\uffb4\010" +
    "\uffd3\012\uffd3\014\uffd3\015\uffd3\017\uffd3\020\uffd3\023\uffd3" +
    "\027\uffd3\037\uffd3\001\002\000\026\005\uffd0\010\uffd0\012" +
    "\uffd0\014\uffd0\015\uffd0\017\uffd0\020\uffd0\023\uffd0\027\uffd0" +
    "\037\uffd0\001\002\000\006\006\uffd2\007\uffd2\001\002\000" +
    "\026\005\uffcc\010\uffcc\012\uffcc\014\uffcc\015\uffcc\017\uffcc" +
    "\020\uffcc\023\uffcc\027\uffcc\037\uffcc\001\002\000\006\006" +
    "\220\007\217\001\002\000\004\026\231\001\002\000\004" +
    "\024\uffd3\001\002\000\004\024\127\001\002\000\004\026" +
    "\223\001\002\000\020\005\uffc4\010\uffc4\014\uffc4\015\uffc4" +
    "\020\uffc4\023\uffc4\037\uffc4\001\002\000\020\005\uffd4\010" +
    "\uffd4\014\uffd4\015\uffd4\020\uffd4\023\uffd4\037\uffd4\001\002" +
    "\000\020\005\026\010\030\014\040\015\037\020\031\023" +
    "\020\037\027\001\002\000\022\005\026\010\030\014\040" +
    "\015\037\020\031\023\020\027\uffc3\037\027\001\002\000" +
    "\004\027\230\001\002\000\032\005\uffcf\006\uffcf\007\uffcf" +
    "\010\uffcf\012\uffcf\014\uffcf\015\uffcf\017\uffcf\020\uffcf\023" +
    "\uffcf\027\uffcf\037\uffcf\001\002\000\020\005\uffc4\010\uffc4" +
    "\014\uffc4\015\uffc4\020\uffc4\023\uffc4\037\uffc4\001\002\000" +
    "\020\005\uffd3\010\uffd3\014\uffd3\015\uffd3\020\uffd3\023\uffd3" +
    "\037\uffd3\001\002\000\020\005\026\010\030\014\040\015" +
    "\037\020\031\023\020\037\027\001\002\000\022\005\026" +
    "\010\030\014\040\015\037\020\031\023\020\027\uffc3\037" +
    "\027\001\002\000\004\027\236\001\002\000\026\005\uffcd" +
    "\010\uffcd\012\uffcd\014\uffcd\015\uffcd\017\uffcd\020\uffcd\023" +
    "\uffcd\027\uffcd\037\uffcd\001\002\000\026\005\uffcb\010\uffcb" +
    "\012\uffcb\014\uffcb\015\uffcb\017\uffcb\020\uffcb\023\uffcb\027" +
    "\uffcb\037\uffcb\001\002\000\004\024\252\001\002\000\026" +
    "\005\uffc7\010\uffc7\012\uffc7\014\uffc7\015\uffc7\017\uffc7\020" +
    "\uffc7\023\uffc7\027\uffc7\037\uffc7\001\002\000\004\004\243" +
    "\001\002\000\020\005\uffc4\010\uffc4\014\uffc4\015\uffc4\020" +
    "\uffc4\023\uffc4\037\uffc4\001\002\000\020\005\026\010\030" +
    "\014\040\015\037\020\031\023\020\037\027\001\002\000" +
    "\022\005\026\010\030\012\uffc3\014\040\015\037\020\031" +
    "\023\020\037\027\001\002\000\004\012\247\001\002\000" +
    "\004\031\250\001\002\000\004\027\251\001\002\000\026" +
    "\005\uffc8\010\uffc8\012\uffc8\014\uffc8\015\uffc8\017\uffc8\020" +
    "\uffc8\023\uffc8\027\uffc8\037\uffc8\001\002\000\022\020\031" +
    "\022\055\024\056\036\044\037\046\040\uffe7\041\054\042" +
    "\047\001\002\000\004\025\254\001\002\000\004\004\255" +
    "\001\002\000\020\005\uffc4\010\uffc4\014\uffc4\015\uffc4\020" +
    "\uffc4\023\uffc4\037\uffc4\001\002\000\020\005\026\010\030" +
    "\014\040\015\037\020\031\023\020\037\027\001\002\000" +
    "\022\005\026\010\030\012\uffc3\014\040\015\037\020\031" +
    "\023\020\037\027\001\002\000\004\012\261\001\002\000" +
    "\004\031\262\001\002\000\010\011\uffca\013\uffca\027\uffca" +
    "\001\002\000\022\020\031\022\055\024\056\036\044\037" +
    "\046\040\uffe7\041\054\042\047\001\002\000\004\025\265" +
    "\001\002\000\004\031\266\001\002\000\026\005\uffde\010" +
    "\uffde\012\uffde\014\uffde\015\uffde\017\uffde\020\uffde\023\uffde" +
    "\027\uffde\037\uffde\001\002\000\004\037\270\001\002\000" +
    "\004\025\271\001\002\000\004\031\272\001\002\000\004" +
    "\002\ufffe\001\002\000\004\037\274\001\002\000\004\024" +
    "\275\001\002\000\006\025\uffbe\037\300\001\002\000\006" +
    "\025\uffbf\030\303\001\002\000\004\025\uffc0\001\002\000" +
    "\004\004\301\001\002\000\004\037\302\001\002\000\006" +
    "\025\uffbc\030\uffbc\001\002\000\004\037\304\001\002\000" +
    "\004\004\305\001\002\000\004\037\306\001\002\000\006" +
    "\025\uffbd\030\uffbd\001\002" });

  /** Access to parse-action table. */
  public short[][] action_table() {return _action_table;}

  /** <code>reduce_goto</code> table. */
  protected static final short[][] _reduce_table = 
    unpackFromStrings(new String[] {
    "\000\304\000\006\002\004\003\003\001\001\000\004\041" +
    "\006\001\001\000\002\001\001\000\002\001\001\000\006" +
    "\004\012\042\011\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\004\026\015\001\001\000\032\005\033\006\024\020" +
    "\035\023\021\024\022\034\023\037\031\040\034\045\040" +
    "\047\016\051\020\052\032\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\004" +
    "\025\236\001\001\000\002\001\001\000\002\001\001\000" +
    "\006\013\202\030\125\001\001\000\004\035\143\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\026\006\135\020\035\023\021\024\022" +
    "\034\023\037\031\040\034\047\016\051\020\052\032\001" +
    "\001\000\002\001\001\000\002\001\001\000\004\026\137" +
    "\001\001\000\006\017\123\053\124\001\001\000\004\046" +
    "\041\001\001\000\004\027\121\001\001\000\014\007\050" +
    "\012\044\030\051\036\047\047\052\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\016" +
    "\010\066\011\063\012\057\031\061\032\065\033\056\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\014\007\050\012\044\030\051\036\105\047\052\001\001" +
    "\000\002\001\001\000\002\001\001\000\016\010\071\011" +
    "\063\012\057\031\070\032\065\033\056\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\006\011" +
    "\074\012\057\001\001\000\002\001\001\000\010\010\071" +
    "\011\063\012\057\001\001\000\002\001\001\000\002\001" +
    "\001\000\006\032\102\033\056\001\001\000\010\031\070" +
    "\032\065\033\056\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\014\007\050" +
    "\012\044\030\051\036\107\047\052\001\001\000\002\001" +
    "\001\000\002\001\001\000\006\011\112\012\057\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\006\013" +
    "\127\030\125\001\001\000\002\001\001\000\002\001\001" +
    "\000\010\031\061\032\065\033\056\001\001\000\002\001" +
    "\001\000\004\026\131\001\001\000\004\014\132\001\001" +
    "\000\030\005\133\006\024\020\035\023\021\024\022\034" +
    "\023\037\031\040\034\047\016\051\020\052\032\001\001" +
    "\000\030\006\135\020\035\023\021\024\022\027\134\034" +
    "\023\037\031\040\034\047\016\051\020\052\032\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\004\034\141\001\001\000\004\030\154" +
    "\001\001\000\004\035\143\001\001\000\002\001\001\000" +
    "\002\001\001\000\004\034\146\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\014\007\050\012" +
    "\044\030\051\036\152\047\052\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\004\037\156\001" +
    "\001\000\002\001\001\000\002\001\001\000\014\007\050" +
    "\012\044\030\051\036\161\047\052\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\030\005\165" +
    "\006\024\020\035\023\021\024\022\034\023\037\031\040" +
    "\034\047\016\051\020\052\032\001\001\000\030\006\135" +
    "\020\035\023\021\024\022\027\166\034\023\037\031\040" +
    "\034\047\016\051\020\052\032\001\001\000\002\001\001" +
    "\000\002\001\001\000\004\050\171\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\014\007\050" +
    "\012\044\030\051\036\175\047\052\001\001\000\002\001" +
    "\001\000\014\007\050\012\044\030\051\036\177\047\052" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\004\026\204\001\001\000\004" +
    "\014\205\001\001\000\030\005\206\006\024\020\035\023" +
    "\021\024\022\034\023\037\031\040\034\047\016\051\020" +
    "\052\032\001\001\000\030\006\135\020\035\023\021\024" +
    "\022\027\207\034\023\037\031\040\034\047\016\051\020" +
    "\052\032\001\001\000\002\001\001\000\004\021\211\001" +
    "\001\000\012\015\214\016\215\022\212\053\213\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\004\015\220\001\001" +
    "\000\006\013\221\030\125\001\001\000\002\001\001\000" +
    "\004\026\223\001\001\000\004\014\224\001\001\000\030" +
    "\005\225\006\024\020\035\023\021\024\022\034\023\037" +
    "\031\040\034\047\016\051\020\052\032\001\001\000\030" +
    "\006\135\020\035\023\021\024\022\027\226\034\023\037" +
    "\031\040\034\047\016\051\020\052\032\001\001\000\002" +
    "\001\001\000\002\001\001\000\004\026\231\001\001\000" +
    "\004\015\232\001\001\000\030\005\233\006\024\020\035" +
    "\023\021\024\022\034\023\037\031\040\034\047\016\051" +
    "\020\052\032\001\001\000\030\006\135\020\035\023\021" +
    "\024\022\027\234\034\023\037\031\040\034\047\016\051" +
    "\020\052\032\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\004\026\243\001\001\000\030\005\244" +
    "\006\024\020\035\023\021\024\022\034\023\037\031\040" +
    "\034\047\016\051\020\052\032\001\001\000\030\006\135" +
    "\020\035\023\021\024\022\027\245\034\023\037\031\040" +
    "\034\047\016\051\020\052\032\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\014\007\050\012\044\030\051\036\252\047\052\001\001" +
    "\000\002\001\001\000\002\001\001\000\004\026\255\001" +
    "\001\000\030\005\256\006\024\020\035\023\021\024\022" +
    "\034\023\037\031\040\034\047\016\051\020\052\032\001" +
    "\001\000\030\006\135\020\035\023\021\024\022\027\257" +
    "\034\023\037\031\040\034\047\016\051\020\052\032\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\014\007\050\012\044\030\051\036\263\047\052\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\006" +
    "\043\276\044\275\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001" });

  /** Access to <code>reduce_goto</code> table. */
  public short[][] reduce_table() {return _reduce_table;}

  /** Instance of action encapsulation class. */
  protected CUP$Parser$actions action_obj;

  /** Action encapsulation object initializer. */
  protected void init_actions()
    {
      action_obj = new CUP$Parser$actions(this);
    }

  /** Invoke a user supplied parse action. */
  public java_cup.runtime.Symbol do_action(
    int                        act_num,
    java_cup.runtime.lr_parser parser,
    java.util.Stack            stack,
    int                        top)
    throws java.lang.Exception
  {
    /* call code in generated class */
    return action_obj.CUP$Parser$do_action(act_num, parser, stack, top);
  }

  /** Indicates start state. */
  public int start_state() {return 0;}
  /** Indicates start production. */
  public int start_production() {return 0;}

  /** <code>EOF</code> Symbol index. */
  public int EOF_sym() {return 0;}

  /** <code>error</code> Symbol index. */
  public int error_sym() {return 1;}



    private ScannerLex scanner;
    private boolean hasToGenerateDigraph;
    private SymbolsTable symbolsTable;
    private Digraph digraph;

    private Stack<String> stackTrueCond;
    private Stack<String> stackFalseCond;

    private BackendManager backendManager;

    public Parser(ScannerLex scanner, SymbolFactory sf, boolean hasToGenerateDigraph) {
        super(scanner);
        this.scanner = scanner;
        this.hasToGenerateDigraph = hasToGenerateDigraph;
        this.symbolsTable = new SymbolsTable();
        this.digraph = new Digraph();

        this.stackTrueCond = new Stack<String>();
        this.stackFalseCond = new Stack<String>();

        backendManager = new BackendManager();
    }

    // In case of syntactic error
    public void report_fatal_error(String message, Object info) {
        String msgError = "Syntactic error";
        if (info instanceof java_cup.runtime.Symbol) {
            java_cup.runtime.Symbol symbol = ((java_cup.runtime.Symbol) info );

        if (symbol.left >= 0) {
            msgError += " in line "+(symbol.left+1);
            if (symbol.right>=0)
                msgError += ", column "+(symbol.right+1);
            }
        }

        msgError += ". Error message: " + message;
        System.err.println(msgError);

        try {
            throw new MalformedStructureException(
                 CompilerException.CompilerErrorType.syntactic,
                 msgError
            );
         } catch (MalformedStructureException ex) {
             System.err.println("ERROR: " + ex.getMessage());
         }

        report_error(message, info);
        System.exit(1);
    }

    private void initializeTypeInt() {
        String keywordType = "int";
        TypeDescription typeDescription = new TypeDescription(
            TypeDescription.CONTENT_DESCRIPTION.dtype,
            TypeDescription.BASIC_SUBJACENT_TYPE.ts_integer,
            4, // bytes
            Integer.MIN_VALUE,
            Integer.MAX_VALUE
        );

        this.symbolsTable.add(keywordType, typeDescription);
    }

    private void initializeTypeBoolean() {
        String keywordType = "boolean";
        TypeDescription typeDescription = new TypeDescription(
            TypeDescription.CONTENT_DESCRIPTION.dtype,
            TypeDescription.BASIC_SUBJACENT_TYPE.ts_boolean,
            2, // bytes
            0,
            1
            );

        this.symbolsTable.add(keywordType, typeDescription);
        
    }

    private void initializeTypeString() {
        String keywordType = "string";
        TypeDescription typeDescription = new TypeDescription(
            TypeDescription.CONTENT_DESCRIPTION.dtype,
            TypeDescription.BASIC_SUBJACENT_TYPE.ts_string,
            0, // bytes
            0,
            1024
            );

        this.symbolsTable.add(keywordType, typeDescription);
    }

    private void initializeTypeNone() {
        String keywordType = "none";
        TypeDescription typeDescription = new TypeDescription(
            TypeDescription.CONTENT_DESCRIPTION.dtype,
            TypeDescription.BASIC_SUBJACENT_TYPE.ts_none,
            0, // bytes
            0,
            0
            );

        this.symbolsTable.add(keywordType, typeDescription);
    }



/** Cup generated class to encapsulate user supplied action code.*/
@SuppressWarnings({"rawtypes", "unchecked", "unused"})
class CUP$Parser$actions {
  private final Parser parser;

  /** Constructor */
  CUP$Parser$actions(Parser parser) {
    this.parser = parser;
  }

  /** Method 0 with the actual generated action code for actions 0 to 300. */
  public final java_cup.runtime.Symbol CUP$Parser$do_action_part00000000(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack            CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      /* Symbol object for return from actions */
      java_cup.runtime.Symbol CUP$Parser$result;

      /* select the action based on the action number */
      switch (CUP$Parser$act_num)
        {
          /*. . . . . . . . . . . . . . . . . . . .*/
          case 0: // $START ::= ROOT EOF 
            {
              Object RESULT =null;
		int start_valleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int start_valright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		SymbolRoot start_val = (SymbolRoot)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		RESULT = start_val;
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("$START",0, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          /* ACCEPT */
          CUP$Parser$parser.done_parsing();
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 1: // ROOT ::= INIT_TYPES FUNCTION CALL_MAIN 
            {
              SymbolRoot RESULT =null;
		 
                // ============== GENERATE NODE FOR DIGRAPH ==============
                String description ="[ROOT => INIT_TYPES INSTRS]";

                ArrayList<NodeGraph.VARIABLES> childs = new ArrayList<NodeGraph.VARIABLES>();
                childs.add(NodeGraph.VARIABLES.INIT_TYPES);
                childs.add(NodeGraph.VARIABLES.INSTRS);

                NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.ROOT);
                digraph.addNode(nodeGraph, childs);
                // =======================================================

                // ============== GENERATE DIGRAPH FILE ==============
                if (hasToGenerateDigraph) {
                    digraph.generateDotFile();
                }
                // ===================================================

                symbolsTable.closeFile(); 

                backendManager.tablesManager.updateOffsetOfTables();

                backendManager.storeC3DInstInALogFile("C3D_not_optimized_list.txt");
                backendManager.storeTablesInALogFile();

                backendManager.generateAssemblerCodeWithoutOptimization();
                backendManager.generateAssemblerCodeOptimized();
                backendManager.storeC3DInstInALogFile("C3D_optimized_list.txt");

                boolean hasFinished = true;
                RESULT = new SymbolRoot(hasFinished);
            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ROOT",0, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 2: // INIT_TYPES ::= 
            {
              SymbolInitType RESULT =null;
		  
                    // ============== GENERATE NODE FOR DIGRAPH ==============
                    String description = "[INIT_TYPES => lambda]";

                    NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.INIT_TYPES);
                    digraph.addNode(nodeGraph);
                    // =======================================================

                    initializeTypeInt();
                    initializeTypeBoolean();
                    initializeTypeString();
                    initializeTypeNone(); 
                    RESULT = new SymbolInitType();
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("INIT_TYPES",1, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 3: // CALL_MAIN ::= inst_call_main lparen id rparen final_sentence 
            {
              SymbolCallMain RESULT =null;
		int id_main_functionleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int id_main_functionright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		String id_main_function = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		
                    TypeDescription typeDescription = symbolsTable.query(id_main_function);
                    int idProcedure = typeDescription.idBackend;

                    // ==================== INTERMEDIATE CODE ====================
                        backendManager.generateC3DInst(
                            0 // We put our c3d instruction at the beginning of the list
                            , OpCode.procedureCallMain
                            , null
                            , null
                            , new Operator(idProcedure + "", TypeOperator.procedure)
                        );
                    // ===========================================================

                    RESULT = new SymbolCallMain();
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("CALL_MAIN",2, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 4: // INSTRS ::= INSTRS INSTR 
            {
              SymbolInstrs RESULT =null;
		
                // ============== GENERATE NODE FOR DIGRAPH ==============
                String description ="[INSTRS => INSTRS INSTR]";

                ArrayList<NodeGraph.VARIABLES> childs = new ArrayList<NodeGraph.VARIABLES>();
                childs.add(NodeGraph.VARIABLES.INSTRS);
                childs.add(NodeGraph.VARIABLES.INSTR);

                NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.INSTRS);
                digraph.addNode(nodeGraph, childs);
                // =======================================================

                RESULT = new SymbolInstrs();
            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("INSTRS",3, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 5: // INSTRS ::= INSTR 
            {
              SymbolInstrs RESULT =null;
		
                // ============== GENERATE NODE FOR DIGRAPH ==============
                String description ="[INSTRS => INSTR]";
                ArrayList<NodeGraph.VARIABLES> childs = new ArrayList<NodeGraph.VARIABLES>();
                childs.add(NodeGraph.VARIABLES.INSTR);

                NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.INSTRS);
                digraph.addNode(nodeGraph, childs);
                // =======================================================

                RESULT = new SymbolInstrs();
            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("INSTRS",3, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 6: // INSTR ::= DECLS 
            {
              SymbolInstr RESULT =null;
		
                // ============== GENERATE NODE FOR DIGRAPH ==============
                String description ="[INSTR => DECLS]";

                ArrayList<NodeGraph.VARIABLES> childs = new ArrayList<NodeGraph.VARIABLES>();
                childs.add(NodeGraph.VARIABLES.DECLS);

                NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.INSTR);
                digraph.addNode(nodeGraph, childs);
                // =======================================================

                RESULT = new SymbolInstr();
            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("INSTR",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 7: // INSTR ::= COND_IF 
            {
              SymbolInstr RESULT =null;
		
                // ============== GENERATE NODE FOR DIGRAPH ==============
                String description ="[INSTR => COND_IF]";

                ArrayList<NodeGraph.VARIABLES> childs = new ArrayList<NodeGraph.VARIABLES>();
                childs.add(NodeGraph.VARIABLES.COND_IF);

                NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.INSTR);
                digraph.addNode(nodeGraph, childs);
                // =======================================================

                RESULT = new SymbolInstr();
            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("INSTR",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 8: // INSTR ::= SWITCH 
            {
              SymbolInstr RESULT =null;
		
                // ============== GENERATE NODE FOR DIGRAPH ==============
                String description ="[INSTR => SWITCH]";

                ArrayList<NodeGraph.VARIABLES> childs = new ArrayList<NodeGraph.VARIABLES>();
                childs.add(NodeGraph.VARIABLES.SWITCH);

                NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.INSTR);
                digraph.addNode(nodeGraph, childs);
                // =======================================================

                RESULT = new SymbolInstr();
            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("INSTR",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 9: // INSTR ::= WHILE 
            {
              SymbolInstr RESULT =null;
		
                // ============== GENERATE NODE FOR DIGRAPH ==============
                String description ="[INSTR => WHILE]";

                ArrayList<NodeGraph.VARIABLES> childs = new ArrayList<NodeGraph.VARIABLES>();
                childs.add(NodeGraph.VARIABLES.WHILE);

                NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.INSTR);
                digraph.addNode(nodeGraph, childs);
                // =======================================================

                RESULT = new SymbolInstr();
            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("INSTR",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 10: // INSTR ::= FOR 
            {
              SymbolInstr RESULT =null;
		
                // ============== GENERATE NODE FOR DIGRAPH ==============
                String description ="[INSTR => FOR]";

                ArrayList<NodeGraph.VARIABLES> childs = new ArrayList<NodeGraph.VARIABLES>();
                childs.add(NodeGraph.VARIABLES.FOR);

                NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.INSTR);
                digraph.addNode(nodeGraph, childs);
                // =======================================================

                RESULT = new SymbolInstr();
            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("INSTR",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 11: // INSTR ::= ASSIGN 
            {
              SymbolInstr RESULT =null;
		
                // ============== GENERATE NODE FOR DIGRAPH ==============
                String description ="[INSTR => ASSIGN]";

                ArrayList<NodeGraph.VARIABLES> childs = new ArrayList<NodeGraph.VARIABLES>();
                childs.add(NodeGraph.VARIABLES.ASSIGN);

                NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.INSTR);
                digraph.addNode(nodeGraph, childs);
                // =======================================================

                RESULT = new SymbolInstr();
            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("INSTR",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 12: // INSTR ::= OUTPUT 
            {
              SymbolInstr RESULT =null;
		
                // ============== GENERATE NODE FOR DIGRAPH ==============
                String description ="[INSTR => OUTPUT]";

                ArrayList<NodeGraph.VARIABLES> childs = new ArrayList<NodeGraph.VARIABLES>();
                childs.add(NodeGraph.VARIABLES.OUTPUT);

                NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.INSTR);
                digraph.addNode(nodeGraph, childs);
                // =======================================================

                RESULT = new SymbolInstr();
            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("INSTR",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 13: // INSTR ::= CALL 
            {
              SymbolInstr RESULT =null;
		
                // ============== GENERATE NODE FOR DIGRAPH ==============
                String description ="[INSTR => CALL]";

                ArrayList<NodeGraph.VARIABLES> childs = new ArrayList<NodeGraph.VARIABLES>();
                childs.add(NodeGraph.VARIABLES.CALL);

                NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.INSTR);
                digraph.addNode(nodeGraph, childs);
                // =======================================================

                RESULT = new SymbolInstr();
            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("INSTR",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 14: // DECLS ::= id separator DECLS 
            {
              SymbolDecls RESULT =null;
		int id_variableleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int id_variableright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		String id_variable = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int declsleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int declsright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		SymbolDecls decls = (SymbolDecls)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 
                // ============== GENERATE NODE FOR DIGRAPH ==============
                String description = "[DECLS => id separator DECLS]";

                ArrayList<NodeGraph.VARIABLES> childs = new ArrayList<NodeGraph.VARIABLES>();
                childs.add(NodeGraph.VARIABLES.DECLS);

                NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.DECLS);
                digraph.addNode(nodeGraph, childs);
                // =======================================================

                SymbolDecls symbolDecls = decls;

                TypeDescription typeDescription = symbolDecls.typeDescription;
                // ==================== INTERMEDIATE CODE ====================
                    int isArgument = 0; // Is not an argument
                    int idVar = backendManager.tablesManager.addVariable(id_variable, backendManager.tablesManager.getActualProcedure(), typeDescription.size, isArgument, typeDescription.basicSubjacentType);
                    typeDescription.idBackend = idVar;
                // ===========================================================
                symbolsTable.add(id_variable, typeDescription);

                // ==================== INTERMEDIATE CODE ====================
                    backendManager.generateC3DInst(
                        OpCode.assign
                        , new Operator(symbolDecls.idVariable, TypeOperator.variable)
                        , null
                        , new Operator(idVar + "", TypeOperator.variable)
                    );
                // ===========================================================

                RESULT = symbolDecls;
            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("DECLS",26, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 15: // DECLS ::= id CONSTANT two_points id op_assign VALUE final_sentence 
            {
              SymbolDecls RESULT =null;
		int id_variableleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-6)).left;
		int id_variableright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-6)).right;
		String id_variable = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-6)).value;
		int symbol_constantleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)).left;
		int symbol_constantright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)).right;
		SymbolConstant symbol_constant = (SymbolConstant)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-5)).value;
		int type_variableleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int type_variableright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		String type_variable = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int symbol_valueleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int symbol_valueright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		SymbolValue symbol_value = (SymbolValue)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
                // ============== GENERATE NODE FOR DIGRAPH ==============
                String description = "[DECLS => id CONSTANT two_points id op_assign VALUE final_sentence ]";

                ArrayList<NodeGraph.VARIABLES> childs = new ArrayList<NodeGraph.VARIABLES>();
                childs.add(NodeGraph.VARIABLES.CONSTANT);
                childs.add(NodeGraph.VARIABLES.VALUE);

                NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.DECLS);
                digraph.addNode(nodeGraph, childs);
                // =======================================================

                // ================ CHECK IF TYPE IS CORRECT ===========================
                TypeDescription typeDescription = symbolsTable.query((String) type_variable);

                if (typeDescription.contentDescription != TypeDescription.CONTENT_DESCRIPTION.dtype) {
                    throw new IncorrectTypeException(
                            CompilerException.CompilerErrorType.semantic,
                            "Error to declarate variable '" + id_variable + "'. You content description must be '" + TypeDescription.CONTENT_DESCRIPTION.dtype + "' but it's '" + typeDescription.contentDescription + "'"
                        );
                }

                if (!   (typeDescription.basicSubjacentType == TypeDescription.BASIC_SUBJACENT_TYPE.ts_integer
                            || typeDescription.basicSubjacentType == TypeDescription.BASIC_SUBJACENT_TYPE.ts_boolean
                            || typeDescription.basicSubjacentType == TypeDescription.BASIC_SUBJACENT_TYPE.ts_string
                        )
                    ) { 
                        throw new IncorrectTypeException(
                            CompilerException.CompilerErrorType.semantic,
                            "Error to declarate variable '" + id_variable + "'. Type of variable must have a correct subjacent type. Your basic subjacent type is '" + typeDescription.basicSubjacentType + "'"
                        ); 
                }
                // =====================================================================
                
                // ================ COMPARE TYPE AND VALUE OF VARIABLE ==================
                SymbolValue    symbolValue = symbol_value;
                SymbolConstant symbolConstant = symbol_constant;

                boolean isConstant = false;

                if (symbolConstant != null) {
                    isConstant = symbolConstant.isConstant;
                }

                if (isConstant && !symbolValue.isConstant) {
                    throw new IncorrectTypeException(
                            CompilerException.CompilerErrorType.semantic,
                            "Error to declarate variable '" + id_variable + "'. Value of variable isn't a constant."
                        );
                }

                if (symbolValue.contentDescription == CONTENT_DESCRIPTION.idnull) {
                    if (symbolValue.basicSubjacentType != typeDescription.basicSubjacentType){
                        throw new IncorrectTypeException(
                            CompilerException.CompilerErrorType.semantic,
                            "Error to declarate variable '" + id_variable + "'. Type of variable and it's value must have the same subjacent type."
                            + " Subjacent type of type: " + typeDescription.basicSubjacentType + ". "
                            + "Subjacent type of value: " + symbolValue.basicSubjacentType + "."
                            ); 
                    }

                } else if (symbolValue.contentDescription == CONTENT_DESCRIPTION.dconst
                    || symbolValue.contentDescription == CONTENT_DESCRIPTION.dvar
                    || symbolValue.contentDescription == CONTENT_DESCRIPTION.darg
                    || symbolValue.contentDescription == CONTENT_DESCRIPTION.dfunc
                    ) {

                    if (!type_variable.equals(symbolValue.nameType)) {
                        throw new IncorrectTypeException(
                            CompilerException.CompilerErrorType.semantic,
                            "Error to declarate variable '" + id_variable + "'. The type of variable and his value must be the same."
                            + "Type of variable: " + type_variable + ". "
                            + "Type of value: " + symbolValue.nameType + "."
                            );
                    }
                }

                TypeDescription typeDescriptionForNewVariables;

                if (isConstant && symbolValue.isConstant) {
                    typeDescriptionForNewVariables = new TypeDescription(
                    CONTENT_DESCRIPTION.dconst,
                    type_variable,
                    symbolValue.valueType
                    );

                } else {
                    typeDescriptionForNewVariables = new TypeDescription(
                    CONTENT_DESCRIPTION.dvar,
                    type_variable
                    );
                }

                // ==================== INTERMEDIATE CODE ====================
                    int variableSize = typeDescription.size;
                    if (symbolValue.isString) variableSize = symbolValue.stringSize;

                    int isArgument = 0; // Is not an argument
                    int idVar = backendManager.tablesManager.addVariable(id_variable, backendManager.tablesManager.getActualProcedure(), variableSize, isArgument, typeDescription.basicSubjacentType);
                    typeDescriptionForNewVariables.idBackend = idVar;
                // ===========================================================

                symbolsTable.add(id_variable, typeDescriptionForNewVariables);

                SymbolDecls symbolDecls = new SymbolDecls(typeDescriptionForNewVariables);
                
                // ===========================================================
                    symbolDecls.idVariable = symbolValue.idVariable;
                    backendManager.generateC3DInst(
                        OpCode.assign
                        , new Operator(symbolValue.idVariable, TypeOperator.variable)
                        , null
                        , new Operator(idVar + "", TypeOperator.variable)
                    );
                // ===========================================================

                RESULT = symbolDecls;
            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("DECLS",26, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-6)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 16: // CONSTANT ::= constant 
            {
              SymbolConstant RESULT =null;
		
                    // ============== GENERATE NODE FOR DIGRAPH ==============
                    String description = "[CONSTANT => constant]";

                    NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.CONSTANT);
                    digraph.addNode(nodeGraph);
                    // =======================================================
                    boolean isConstant = true;
                    RESULT = new SymbolConstant(isConstant);
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("CONSTANT",27, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 17: // CONSTANT ::= 
            {
              SymbolConstant RESULT =null;
		
                    // ============== GENERATE NODE FOR DIGRAPH ==============
                    String description = "[CONSTANT => lambda]";

                    NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.CONSTANT);
                    digraph.addNode(nodeGraph);
                    // =======================================================

                    boolean isConstant = false;
                    RESULT = new SymbolConstant(isConstant);

                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("CONSTANT",27, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 18: // ASSIGN ::= id op_assign VALUE final_sentence 
            {
              SymbolAssign RESULT =null;
		int id_variableleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int id_variableright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		String id_variable = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int symbol_valueleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int symbol_valueright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		SymbolValue symbol_value = (SymbolValue)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
                                        // ============== GENERATE NODE FOR DIGRAPH ==============
                                        String description = "[ASSIGN => id op_assign VALUE final_sentence]";

                                        ArrayList<NodeGraph.VARIABLES> childs = new ArrayList<NodeGraph.VARIABLES>();
                                        childs.add(NodeGraph.VARIABLES.VALUE);

                                        NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.ASSIGN);
                                        digraph.addNode(nodeGraph, childs);
                                        // =======================================================

                                       // ================ COMPARE TYPE AND VALUE OF VARIABLE ==================
                                        TypeDescription variableTypeDescription = symbolsTable.query(id_variable);
                                        SymbolValue symbolValue = symbol_value;

                                        if (variableTypeDescription.contentDescription == CONTENT_DESCRIPTION.dconst) {
                                            throw new IncorrectTypeException(
                                                CompilerException.CompilerErrorType.semantic,
                                                "Operation assignment. We can't assign a value to a constant"
                                            ); 
                                        }

                                        if (symbolValue.contentDescription == CONTENT_DESCRIPTION.idnull) {
                                            TypeDescription typeDescriptionParent = symbolsTable.query(variableTypeDescription.nameType);

                                            if (symbolValue.basicSubjacentType != typeDescriptionParent.basicSubjacentType){
                                                throw new IncorrectTypeException(
                                                    CompilerException.CompilerErrorType.semantic,
                                                    "Operation assignment. Type of variable and it's value must have the same subjacent type."
                                                    + " Subjacent type of type: " + typeDescriptionParent.basicSubjacentType + ". "
                                                    + "Subjacent type of value: " + symbolValue.basicSubjacentType + "."
                                                    ); 
                                            }

                                        }else if (symbolValue.contentDescription == CONTENT_DESCRIPTION.dvar
                                                    || symbolValue.contentDescription == CONTENT_DESCRIPTION.darg
                                                    || symbolValue.contentDescription == CONTENT_DESCRIPTION.dfunc
                                                ) {

                                            if (!variableTypeDescription.nameType.equals(symbolValue.nameType)) {
                                                throw new IncorrectTypeException(
                                                    CompilerException.CompilerErrorType.semantic,
                                                    "Operation assignment. The type of variable and his value must be the same."
                                                    + "Type of variable: " + variableTypeDescription.nameType + ". "
                                                    + "Type of value: " + symbolValue.nameType + "."
                                                    );
                                            }
                                        } else {
                                            throw new IncorrectTypeException(
                                                    CompilerException.CompilerErrorType.semantic,
                                                    "The value has an incorrect type: " + symbolValue.contentDescription + "."
                                            );
                                        }

                                        // =====================================================================

                                        //Quadruple quadruple = new Quadruple(OP_CODE.assignRef, symbolValue.idVariable, "", id_variable);
                                        //quadruples.add(quadruple);

                                        // ==================== INTERMEDIATE CODE ====================

                                            backendManager.generateC3DInst(
                                                OpCode.assign
                                                , new Operator(symbolValue.idVariable, TypeOperator.variable)
                                                , null
                                                , new Operator(variableTypeDescription.idBackend + "", TypeOperator.variable)
                                            );
                                            
                                        // ===========================================================
                                        RESULT = new SymbolAssign();
                                    
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ASSIGN",29, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 19: // INIT_OP_ARITH ::= lparen OP_ARITHMETIC rparen 
            {
              SymbolInitOpArith RESULT =null;
		int op_arithleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int op_arithright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		SymbolOpArithmetic op_arith = (SymbolOpArithmetic)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
                        // ============== GENERATE NODE FOR DIGRAPH ==============
                        String description ="[INIT_OP_ARITH => lparen OP_ARITHMETIC rparen]";

                        ArrayList<NodeGraph.VARIABLES> childs = new ArrayList<NodeGraph.VARIABLES>();
                        childs.add(NodeGraph.VARIABLES.OP_ARITHMETIC);

                        NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.INIT_OP_ARITH);
                        digraph.addNode(nodeGraph, childs);
                        // =======================================================
                        SymbolOpArithmetic symbolOpArithmetic = op_arith;
                        SymbolInitOpArith symbolInitOpArith = new SymbolInitOpArith();

                        symbolInitOpArith.isConstant = symbolOpArithmetic.isConstant;

                        if (symbolOpArithmetic.isConstant) {
                            symbolInitOpArith.valueType = symbolOpArithmetic.valueType;
                        }

                        symbolInitOpArith.idVariable = symbolOpArithmetic.idVariable;
                        RESULT = symbolInitOpArith;
                    
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("INIT_OP_ARITH",5, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 20: // OP_ARITHMETIC ::= OP_ARITHMETIC op_arithmetic OP_ARITH_VALUE 
            {
              SymbolOpArithmetic RESULT =null;
		int op_arithmetic_valleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int op_arithmetic_valright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		SymbolOpArithmetic op_arithmetic_val = (SymbolOpArithmetic)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int op_arithmeticleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int op_arithmeticright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		String op_arithmetic = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int op_arith_valueleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int op_arith_valueright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		SymbolOpArithValue op_arith_value = (SymbolOpArithValue)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 
                        // ============== GENERATE NODE FOR DIGRAPH ==============
                        String description = "[OP_ARITHMETIC => OP_ARITHMETIC op_arithmetic OP_ARITH_VALUE]";

                        ArrayList<NodeGraph.VARIABLES> childs = new ArrayList<NodeGraph.VARIABLES>();
                        childs.add(NodeGraph.VARIABLES.OP_ARITHMETIC);
                        childs.add(NodeGraph.VARIABLES.OP_ARITH_VALUE);

                        NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.OP_ARITHMETIC);
                        digraph.addNode(nodeGraph, childs);
                        // =======================================================
                        SymbolOpArithmetic symbolOpArithmeticVal = op_arithmetic_val;
                        SymbolOpArithValue symbolOpArithValue = op_arith_value;

                        SymbolOpArithmetic symbolOpArithmetic = new SymbolOpArithmetic();

                        OpCode opCode = OpCode.sum;
                        switch(op_arithmetic) {
                            case "+": 
                                    opCode = OpCode.sum;
                                    break;
                            case "-": 
                                    opCode = OpCode.sub;
                                    break;
                            case "*": 
                                    opCode = OpCode.mult;
                                    break;
                            case "/": 
                                    opCode = OpCode.div;
                                    break;
                        }
                        // We can calculate the value if all operands are constant
                        if (symbolOpArithmetic.isConstant && symbolOpArithValue.isConstant) {
                            symbolOpArithmetic.isConstant = true;

                            Integer newValue = -1;
                            Integer value1 = (Integer) symbolOpArithmeticVal.valueType;
                            Integer value2 = (Integer) symbolOpArithValue.valueType;

                            switch(op_arithmetic) {
                                case "+": newValue = value1 + value2; 
                                        break;
                                case "-": newValue = value1 - value2; 
                                        break;
                                case "*": newValue = value1 * value2;
                                        break;
                                case "/": 
                                    if (value2 == 0) {
                                        throw new DivisionByZeroException("You can't divide by zero. Your operation " + value1 + "/" + value2 + " is invalid");
                                    }
                                    newValue = value1 / value2;
                                    break;
                            }

                            symbolOpArithmetic.valueType = newValue;

                        }

                        // ==================== INTERMEDIATE CODE ====================
                            TypeDescription typeInt = symbolsTable.query("int");
                            int isArgument = 0; // Is not an argument
                            int idVar = backendManager.tablesManager.addTemporalVariable(backendManager.tablesManager.getActualProcedure(), typeInt.size, 0, typeInt.basicSubjacentType);
                            symbolOpArithmetic.idVariable = idVar + "";

                            backendManager.generateC3DInst(
                                opCode
                                , new Operator(symbolOpArithmeticVal.idVariable, TypeOperator.variable)
                                , new Operator(symbolOpArithValue.idVariable, TypeOperator.variable)
                                , new Operator(idVar + "", TypeOperator.variable)
                            );
                        // ===========================================================
                        RESULT = symbolOpArithmetic;
                    
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("OP_ARITHMETIC",6, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 21: // OP_ARITHMETIC ::= OP_ARITH_VALUE op_arithmetic OP_ARITH_VALUE 
            {
              SymbolOpArithmetic RESULT =null;
		int op_arith_value1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int op_arith_value1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		SymbolOpArithValue op_arith_value1 = (SymbolOpArithValue)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int op_arithmeticleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int op_arithmeticright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		String op_arithmetic = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int op_arith_value2left = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int op_arith_value2right = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		SymbolOpArithValue op_arith_value2 = (SymbolOpArithValue)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 
                        // ============== GENERATE NODE FOR DIGRAPH ==============
                        String description = "[OP_ARITHMETIC => OP_ARITH_VALUE op_arithmetic OP_ARITH_VALUE]";

                        ArrayList<NodeGraph.VARIABLES> childs = new ArrayList<NodeGraph.VARIABLES>();
                        childs.add(NodeGraph.VARIABLES.OP_ARITH_VALUE);
                        childs.add(NodeGraph.VARIABLES.OP_ARITH_VALUE);

                        NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.OP_ARITHMETIC);
                        digraph.addNode(nodeGraph, childs);
                        // =======================================================
                        SymbolOpArithValue symbolOpArithValue1 = op_arith_value1;
                        SymbolOpArithValue symbolOpArithValue2 = op_arith_value2;

                        SymbolOpArithmetic symbolOpArithmetic = new SymbolOpArithmetic();

                        OpCode opCode = OpCode.sum;
                        switch(op_arithmetic) {
                                case "+":
                                        opCode = OpCode.sum;
                                        break;
                                case "-":
                                        opCode = OpCode.sub;
                                        break;
                                case "*":
                                        opCode = OpCode.mult;
                                        break;
                                case "/":
                                        opCode = OpCode.div;
                                        break;

                            }
                        // We can calculate the value if all operands are constant
                        if (symbolOpArithValue1.isConstant && symbolOpArithValue2.isConstant) {
                            symbolOpArithmetic.isConstant = true;

                            Integer newValue = -1;
                            Integer value1 = (Integer) symbolOpArithValue1.valueType;
                            Integer value2 = (Integer) symbolOpArithValue2.valueType;

                            switch(op_arithmetic) {
                                case "+": newValue = value1 + value2;
                                        break;
                                case "-": newValue = value1 - value2;
                                        break;
                                case "*": newValue = value1 * value2;
                                        break;
                                case "/":
                                    if (value2 == 0) {
                                        throw new DivisionByZeroException("You can't divide by zero. Your operation " + value1 + "/" + value2 + " is invalid");
                                    }
                                    newValue = value1 / value2;
                                    break;

                            }
                            symbolOpArithmetic.valueType = newValue;
                        }

                        // ==================== INTERMEDIATE CODE ====================
                            TypeDescription typeInt = symbolsTable.query("int");
                            int isArgument = 0; // Is not an argument
                            int idVar = backendManager.tablesManager.addTemporalVariable(backendManager.tablesManager.getActualProcedure(), typeInt.size, 0, typeInt.basicSubjacentType);
                            symbolOpArithmetic.idVariable = idVar + "";

                            backendManager.generateC3DInst(
                                opCode
                                , new Operator(symbolOpArithValue1.idVariable, TypeOperator.variable)
                                , new Operator(symbolOpArithValue2.idVariable, TypeOperator.variable)
                                , new Operator(idVar + "", TypeOperator.variable)
                            );
                        // ===========================================================
                        RESULT = symbolOpArithmetic; 
                    
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("OP_ARITHMETIC",6, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 22: // OP_ARITH_VALUE ::= lparen OP_ARITHMETIC rparen 
            {
              SymbolOpArithValue RESULT =null;
		int op_aritleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int op_aritright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		SymbolOpArithmetic op_arit = (SymbolOpArithmetic)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		 
                        // ============== GENERATE NODE FOR DIGRAPH ==============
                        String description = "[OP_ARITH_VALUE => lparen OP_ARITHMETIC rparen]";

                        ArrayList<NodeGraph.VARIABLES> childs = new ArrayList<NodeGraph.VARIABLES>();
                        childs.add(NodeGraph.VARIABLES.OP_ARITHMETIC);

                        NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.OP_ARITH_VALUE);
                        digraph.addNode(nodeGraph, childs);
                        // =======================================================
                        SymbolOpArithmetic symbolOpArithmetic = op_arit;
                        SymbolOpArithValue symbolOpArithValue = new SymbolOpArithValue();
                        symbolOpArithValue.isConstant = symbolOpArithmetic.isConstant;

                        if (symbolOpArithmetic.isConstant) {
                            symbolOpArithValue.valueType = symbolOpArithmetic.valueType;
                        }

                        symbolOpArithValue.idVariable = symbolOpArithmetic.idVariable;
                        RESULT = symbolOpArithValue; 
                    
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("OP_ARITH_VALUE",7, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 23: // OP_ARITH_VALUE ::= SIGN number 
            {
              SymbolOpArithValue RESULT =null;
		int signleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int signright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		SymbolSign sign = (SymbolSign)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int number_valleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int number_valright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String number_val = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 
                        // ============== GENERATE NODE FOR DIGRAPH ==============
                        String description = "[OP_ARITH_VALUE => SIGN number]";

                        ArrayList<NodeGraph.VARIABLES> childs = new ArrayList<NodeGraph.VARIABLES>();
                        childs.add(NodeGraph.VARIABLES.SIGN);

                        NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.OP_ARITH_VALUE);
                        digraph.addNode(nodeGraph, childs);
                        // =======================================================

                        Integer number = new Integer(number_val);
                        SymbolSign symbolSign = sign;
                        if (symbolSign != null && symbolSign.isNegative) {
                            number = -number;
                        }

                        SymbolOpArithValue symbolOpArithValue = new SymbolOpArithValue(number);

                        // ==================== INTERMEDIATE CODE ====================
                            TypeDescription typeInt = symbolsTable.query("int");
                            int isArgument = 0; // Is not an argument
                            int idVar = backendManager.tablesManager.addTemporalVariable(backendManager.tablesManager.getActualProcedure(), typeInt.size, 0, typeInt.basicSubjacentType);
                            symbolOpArithValue.idVariable = idVar + "";

                            backendManager.generateC3DInst(
                                OpCode.assign
                                , new Operator(number + "", TypeOperator.int_value)
                                , null
                                , new Operator(idVar + "", TypeOperator.variable)
                            );
                        // ===========================================================

                        RESULT = symbolOpArithValue;
                    
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("OP_ARITH_VALUE",7, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 24: // OP_ARITH_VALUE ::= id 
            {
              SymbolOpArithValue RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                        // ============== GENERATE NODE FOR DIGRAPH ==============
                        String description = "[OP_ARITH_VALUE => id]";

                        NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.OP_ARITH_VALUE);
                        digraph.addNode(nodeGraph);
                        // =======================================================

                        TypeDescription typeDescription = symbolsTable.query(id);
                        if (typeDescription.contentDescription != CONTENT_DESCRIPTION.dvar 
                            && typeDescription.contentDescription != CONTENT_DESCRIPTION.dconst
                            && typeDescription.contentDescription != CONTENT_DESCRIPTION.darg) {
                                throw new IncorrectTypeException(
                                    CompilerException.CompilerErrorType.semantic,
                                    "Arithmetic operation with id '" + id + "'. The value has an incorrect content description: " + typeDescription.contentDescription + "."
                                );
                        }
                        TypeDescription typeDescriptionType = symbolsTable.query(typeDescription.nameType);
                        if (typeDescriptionType.basicSubjacentType != BASIC_SUBJACENT_TYPE.ts_integer) {
                            throw new IncorrectTypeException(
                                    CompilerException.CompilerErrorType.semantic,
                                    "Arithmetic operation with id '" + id + "'. The value has an incorrect subjacent type: " + typeDescriptionType.basicSubjacentType + "."
                            );
                        }

                        SymbolOpArithValue symbolOpArithValue = new SymbolOpArithValue();

                        // We pass the value to the node above when it's a constant
                        if (typeDescription.contentDescription == CONTENT_DESCRIPTION.dconst) {
                            Integer number = (Integer) typeDescription.value;

                            symbolOpArithValue.isConstant = true;
                            symbolOpArithValue.valueType = number;
                        }  

                        symbolOpArithValue.idVariable = typeDescription.idBackend + "";
                        
                        RESULT = symbolOpArithValue; 
                    
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("OP_ARITH_VALUE",7, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 25: // SIGN ::= op_arithmetic 
            {
              SymbolSign RESULT =null;
		int op_aritleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int op_aritright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String op_arit = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 
                // ============== GENERATE NODE FOR DIGRAPH ==============
                String description = "[SIGN => op_arithmetic]";

                NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.SIGN);
                digraph.addNode(nodeGraph);
                // =======================================================

                boolean isNegative = false;

                if (!(op_arit.equals("+") || op_arit.equals("-"))) {
                   throw new IncorrectOperatorException(
                        CompilerException.CompilerErrorType.semantic,
                        "Sign must be '+' or '-'."
                    ); 
                }

                if (op_arit.equals("-")) {
                    isNegative = true;
                }

                RESULT = new SymbolSign(isNegative); 
            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("SIGN",8, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 26: // SIGN ::= 
            {
              SymbolSign RESULT =null;
		 
                // ============== GENERATE NODE FOR DIGRAPH ==============
                String description = "[SIGN => lambda]";

                NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.SIGN);
                digraph.addNode(nodeGraph);
                // =======================================================

                RESULT = new SymbolSign(); 
            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("SIGN",8, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 27: // VALUE ::= INIT_OP_ARITH 
            {
              SymbolValue RESULT =null;
		int init_op_arithleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int init_op_arithright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		SymbolInitOpArith init_op_arith = (SymbolInitOpArith)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 
                    // ============== GENERATE NODE FOR DIGRAPH ==============
                    String description ="[VALUE => INIT_OP_ARITH]";

                    ArrayList<NodeGraph.VARIABLES> childs = new ArrayList<NodeGraph.VARIABLES>();
                    childs.add(NodeGraph.VARIABLES.INIT_OP_ARITH);

                    NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.VALUE);
                    digraph.addNode(nodeGraph, childs);
                    // =======================================================

                    SymbolInitOpArith symbolInitOpArith = init_op_arith;
                    SymbolValue symbolValue = new SymbolValue(BASIC_SUBJACENT_TYPE.ts_integer);

                    symbolValue.isConstant = symbolInitOpArith.isConstant;
                    // If it is a constant, then we pass the value to the higher node
                    if (symbolInitOpArith.isConstant) {
                        symbolValue.valueType = symbolInitOpArith.valueType;
                    }

                    symbolValue.idVariable = symbolInitOpArith.idVariable;
                    RESULT = symbolValue;
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("VALUE",28, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 28: // VALUE ::= INIT_OP_BOOL 
            {
              SymbolValue RESULT =null;
		int init_op_boolleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int init_op_boolright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		SymbolInitOpBool init_op_bool = (SymbolInitOpBool)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                    // ============== GENERATE NODE FOR DIGRAPH ==============
                    String description ="[VALUE => INIT_OP_BOOL]";

                    ArrayList<NodeGraph.VARIABLES> childs = new ArrayList<NodeGraph.VARIABLES>();
                    childs.add(NodeGraph.VARIABLES.INIT_OP_BOOL);

                    NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.VALUE);
                    digraph.addNode(nodeGraph, childs);
                    // =======================================================
                    SymbolInitOpBool symbolInitOpBool = init_op_bool;
                    SymbolValue symbolValue = new SymbolValue(BASIC_SUBJACENT_TYPE.ts_boolean);

                    // If it is a constant, then we pass the value to the higher node
                    if (symbolInitOpBool.isConstant) {
                        symbolValue.isConstant = true;
                        symbolValue.valueType = symbolInitOpBool.valueType;
                    }
                    symbolValue.idVariable = symbolInitOpBool.idVariable;
                    RESULT = symbolValue;
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("VALUE",28, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 29: // VALUE ::= SIGN number 
            {
              SymbolValue RESULT =null;
		int signleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int signright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		SymbolSign sign = (SymbolSign)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int number_valueleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int number_valueright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String number_value = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                    // ============== GENERATE NODE FOR DIGRAPH ==============
                    String description ="[VALUE => SIGN number]";

                    ArrayList<NodeGraph.VARIABLES> childs = new ArrayList<NodeGraph.VARIABLES>();
                    childs.add(NodeGraph.VARIABLES.SIGN);

                    NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.VALUE);
                    digraph.addNode(nodeGraph, childs);
                    // =======================================================

                    Integer value = new Integer(number_value);
                    SymbolSign symbolSign = sign;

                    if (symbolSign != null) {
                        value = (symbolSign.hasSign && symbolSign.isNegative) ? -value : value;
                    }

                    SymbolValue symbolValue = new SymbolValue(BASIC_SUBJACENT_TYPE.ts_integer, value);
                    
                    // ==================== INTERMEDIATE CODE ====================
                    TypeDescription typeInt = symbolsTable.query("int");
                    int isArgument = 0; // Is not an argument
                    int idVar = backendManager.tablesManager.addTemporalVariable(backendManager.tablesManager.getActualProcedure(), typeInt.size, 0, typeInt.basicSubjacentType);
                    symbolValue.idVariable = idVar + "";

                    backendManager.generateC3DInst(
                        OpCode.assign
                        , new Operator(value + "", TypeOperator.int_value)
                        , null
                        , new Operator(idVar + "", TypeOperator.variable)
                    );
                    // ===========================================================

                    RESULT = symbolValue;
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("VALUE",28, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 30: // VALUE ::= text 
            {
              SymbolValue RESULT =null;
		int text_valueleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int text_valueright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String text_value = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 
                    // ============== GENERATE NODE FOR DIGRAPH ==============
                    String description ="[VALUE => text]";

                    NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.VALUE);
                    digraph.addNode(nodeGraph);
                    // =======================================================
                    String value = new String(text_value.replace("\"", "")); // Delete double quote from lexeme

                    SymbolValue symbolValue = new SymbolValue(BASIC_SUBJACENT_TYPE.ts_string, value);
                    
                    // ==================== INTERMEDIATE CODE ====================
                    TypeDescription typeString = symbolsTable.query("string");
                    int isArgument = 0; // Is not an argument
                    int stringSize = value.length() * 2;

                    if (value.length() > 255) {
                        throw new StringSizeOverflowException(
                            "Your string is too large. It has " + value.length() + " characters and must have lower than 255"
                            );

                    }

                    int idVar = backendManager.tablesManager.addTemporalVariable(backendManager.tablesManager.getActualProcedure(), stringSize, 0, typeString.basicSubjacentType);
                    symbolValue.idVariable = idVar + "";
                    symbolValue.isString = true;
                    symbolValue.stringSize = stringSize;

                    backendManager.generateC3DInst(
                        OpCode.assign
                        , new Operator(text_value, TypeOperator.string_value)
                        , null
                        , new Operator(idVar + "", TypeOperator.variable)
                    );
                    // ===========================================================

                    RESULT = symbolValue;
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("VALUE",28, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 31: // VALUE ::= bool 
            {
              SymbolValue RESULT =null;
		int bool_valueleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int bool_valueright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String bool_value = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                    // ============== GENERATE NODE FOR DIGRAPH ==============
                    String description ="[VALUE => bool]";

                    NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.VALUE);
                    digraph.addNode(nodeGraph);
                    // =======================================================
                    Boolean value = new Boolean(bool_value);

                    SymbolValue symbolValue = new SymbolValue(BASIC_SUBJACENT_TYPE.ts_boolean, value);
                    
                    // ==================== INTERMEDIATE CODE ====================
                    TypeDescription typeBoolean = symbolsTable.query("boolean");
                    int isArgument = 0; // Is not an argument
                    int idVar = backendManager.tablesManager.addTemporalVariable(backendManager.tablesManager.getActualProcedure(), typeBoolean.size, 0, typeBoolean.basicSubjacentType);
                    symbolValue.idVariable = idVar + "";

                    backendManager.generateC3DInst(
                        OpCode.assign
                        , new Operator(bool_value, TypeOperator.bool_value)
                        , null
                        , new Operator(idVar + "", TypeOperator.variable)
                    );
                    // ===========================================================

                    RESULT = symbolValue;  
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("VALUE",28, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 32: // VALUE ::= inst_input lparen rparen 
            {
              SymbolValue RESULT =null;
		
                    // ============== GENERATE NODE FOR DIGRAPH ==============
                    String description ="[VALUE => inst_input lparen rparen]";

                    NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.VALUE);
                    digraph.addNode(nodeGraph);
                    // =======================================================
                    TypeDescription typeDescriptionInt = symbolsTable.query("int");
                    SymbolValue symbolValue = new SymbolValue(typeDescriptionInt.basicSubjacentType);
                    
                    // ================ INTERMEDIATE CODE ======================
                        int isArgument = 0; // Is not an argument
                        int idVar = backendManager.tablesManager.addTemporalVariable(backendManager.tablesManager.getActualProcedure(), typeDescriptionInt.size, isArgument, typeDescriptionInt.basicSubjacentType);
                        symbolValue.idVariable = idVar + "";

                        backendManager.generateC3DInst(
                            OpCode.standardInput
                            , null
                            , null
                            , new Operator(idVar + "", TypeOperator.variable)
                        );
                    // =========================================================

                    RESULT = symbolValue;  
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("VALUE",28, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 33: // VALUE ::= id 
            {
              SymbolValue RESULT =null;
		int id_valueleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int id_valueright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String id_value = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                    // ============== GENERATE NODE FOR DIGRAPH ==============
                    String description ="[VALUE => id]";

                    NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.VALUE);
                    digraph.addNode(nodeGraph);
                    // =======================================================

                    TypeDescription typeDescription = symbolsTable.query(id_value);

                    SymbolValue symbolValue = new SymbolValue(
                        typeDescription.contentDescription,
                        typeDescription.nameType
                    );

                    // If it is a constant, then we pass the value to the higher node
                    if (typeDescription.contentDescription == CONTENT_DESCRIPTION.dconst) {   
                        symbolValue.isConstant = true;
                        symbolValue.valueType = typeDescription.value;
                    }

                    symbolValue.idVariable = typeDescription.idBackend + "";

                    RESULT = symbolValue;
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("VALUE",28, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 34: // VALUE ::= CALL 
            {
              SymbolValue RESULT =null;
		int callleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int callright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		SymbolCall call = (SymbolCall)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		

                    // ============== GENERATE NODE FOR DIGRAPH ==============
                    String description ="[VALUE => CALL]";

                    ArrayList<NodeGraph.VARIABLES> childs = new ArrayList<NodeGraph.VARIABLES>();
                    childs.add(NodeGraph.VARIABLES.CALL);

                    NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.VALUE);
                    digraph.addNode(nodeGraph, childs);
                    // =======================================================
                    SymbolCall symbolCall = call;

                    TypeDescription typeDescriptionFunction = symbolsTable.query(symbolCall.idFunction);
                    TypeDescription typeDescriptionType = symbolsTable.query(typeDescriptionFunction.nameType);
                    SymbolValue symbolValue = new SymbolValue(CONTENT_DESCRIPTION.dfunc, typeDescriptionFunction.nameType);

                    // ================ INTERMEDIATE CODE ======================
                    int isArgument = 0; // Is not an argument
                    int idVar = backendManager.tablesManager.addTemporalVariable(backendManager.tablesManager.getActualProcedure(), typeDescriptionType.size, isArgument, typeDescriptionType.basicSubjacentType);
                    symbolValue.idVariable = idVar + "";

                    backendManager.generateC3DInst(
                        OpCode.assign
                        , new Operator(symbolCall.idBackend + "", TypeOperator.procedure)
                        , null
                        , new Operator(idVar + "", TypeOperator.variable)
                    );

                    // =========================================================
                    
                    RESULT = symbolValue;
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("VALUE",28, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 35: // OUTPUT ::= inst_output lparen VALUE rparen final_sentence 
            {
              SymbolOutput RESULT =null;
		int symbol_valueleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int symbol_valueright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		SymbolValue symbol_value = (SymbolValue)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		

                // ============== GENERATE NODE FOR DIGRAPH ==============
                String description ="[OUTPUT => inst_output lparen VALUE rparen final_sentence]";

                ArrayList<NodeGraph.VARIABLES> childs = new ArrayList<NodeGraph.VARIABLES>();
                childs.add(NodeGraph.VARIABLES.VALUE);

                NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.OUTPUT);
                digraph.addNode(nodeGraph, childs);
                // =======================================================

                SymbolValue symbolValue = symbol_value;
                BASIC_SUBJACENT_TYPE subjacentType = BASIC_SUBJACENT_TYPE.ts_none;

                // ======================= GET SUBJACENT TYPE OF OUR VALUE ==========================
                if (!(symbolValue.contentDescription == CONTENT_DESCRIPTION.idnull
                            ||symbolValue.contentDescription == CONTENT_DESCRIPTION.dvar
                            || symbolValue.contentDescription == CONTENT_DESCRIPTION.dconst
                            || symbolValue.contentDescription == CONTENT_DESCRIPTION.darg
                            || symbolValue.contentDescription == CONTENT_DESCRIPTION.dfunc
                        )) {
                        throw new IncorrectTypeException(
                            CompilerException.CompilerErrorType.semantic,
                            "Error in output operation. The value has an incorrect type: " + symbolValue.contentDescription + "."
                        );
                }
                // ====================================================================================

                // ================ INTERMEDIATE CODE ======================
                backendManager.generateC3DInst(
                        OpCode.standardOutput
                        , null
                        , null
                        , new Operator(symbolValue.idVariable + "", TypeOperator.variable)
                );

                // =========================================================
                RESULT = new SymbolOutput();
            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("OUTPUT",30, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 36: // INIT_OP_BOOL ::= lparen OP_BOOLEAN rparen 
            {
              SymbolInitOpBool RESULT =null;
		int op_booleanleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int op_booleanright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		SymbolOpBoolean op_boolean = (SymbolOpBoolean)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
                        // ============== GENERATE NODE FOR DIGRAPH ==============
                        String description ="[INIT_OP_BOOL => lparen OP_BOOLEAN rparen]";

                        ArrayList<NodeGraph.VARIABLES> childs = new ArrayList<NodeGraph.VARIABLES>();
                        childs.add(NodeGraph.VARIABLES.OP_BOOLEAN);

                        NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.INIT_OP_BOOL);
                        digraph.addNode(nodeGraph, childs);
                        // =======================================================
                        SymbolOpBoolean symbolOpBoolean = op_boolean;
                        SymbolInitOpBool symbolInitOpBool = new SymbolInitOpBool();

                        // If it is a constant, then we pass the value to the higher node
                        if (symbolOpBoolean.isConstant) {
                            symbolInitOpBool.isConstant = true;
                            symbolInitOpBool.valueType = symbolOpBoolean.valueType;
                        }
                        
                        // ================ INTERMEDIATE CODE ======================
                            if (!symbolOpBoolean.isSingleBoolean) {
                                //Quadruple quadruple = new Quadruple(OP_CODE.skip, "", "", symbolOpBoolean.idLabel);
                                //quadruples.add(quadruple);
                                backendManager.generateC3DInst(
                                    OpCode.skip
                                    , null
                                    , null
                                    , new Operator(symbolOpBoolean.idLabel, TypeOperator.label)
                                );
                            }
                            
                        // =========================================================

                        symbolInitOpBool.idVariable = symbolOpBoolean.idVariable;

                        RESULT = symbolInitOpBool;
                    
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("INIT_OP_BOOL",22, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 37: // OP_BOOLEAN ::= OP_BOOLEAN op_logic OP_BOOL_VALUE 
            {
              SymbolOpBoolean RESULT =null;
		int op_boolean_val1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int op_boolean_val1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		SymbolOpBoolean op_boolean_val1 = (SymbolOpBoolean)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int op_logicleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int op_logicright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		String op_logic = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int op_boolean_val2left = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int op_boolean_val2right = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		SymbolOpBoolValue op_boolean_val2 = (SymbolOpBoolValue)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                        // ============== GENERATE NODE FOR DIGRAPH ==============
                        String description ="[OP_BOOLEAN => OP_BOOLEAN op_logic OP_BOOL_VALUE]";

                        ArrayList<NodeGraph.VARIABLES> childs = new ArrayList<NodeGraph.VARIABLES>();
                        childs.add(NodeGraph.VARIABLES.OP_BOOLEAN);
                        childs.add(NodeGraph.VARIABLES.OP_BOOL_VALUE);

                        NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.OP_BOOLEAN);
                        digraph.addNode(nodeGraph, childs);
                        // =======================================================
                        SymbolOpBoolean symbolOpBooleanVal1 = op_boolean_val1;
                        SymbolOpBoolValue symbolOpBoolVal2 = op_boolean_val2;
                        SymbolOpBoolean symbolOpBoolean = new SymbolOpBoolean();

                        // If it is a constant, then we calculate the value and pass it to the higher node
                        if (symbolOpBooleanVal1.isConstant && symbolOpBoolVal2.isConstant) {
                            Boolean val1 = (Boolean) symbolOpBooleanVal1.valueType;
                            Boolean val2 = (Boolean) symbolOpBoolVal2.valueType;

                            Boolean newValue = false;

                            switch(op_logic) {
                                case "&&": 
                                    newValue = val1 && val2;
                                break;
                                case "||": 
                                    newValue = val1 || val2;
                                break;
                            }

                            symbolOpBoolean.isConstant = true;
                            symbolOpBoolean.valueType = newValue;

                        }

                        OpCode opCodeVariable = OpCode.and;
                        OpCode opCodeConditional = OpCode.condTrue;

                        switch(op_logic) {
                            case "&&": 
                                opCodeVariable = OpCode.and;
                                opCodeConditional = OpCode.condFalse;
                            break;
                            case "||":
                                opCodeVariable = OpCode.or;
                                opCodeConditional = OpCode.condTrue;
                            break;
                        }

                        // ==================== INTERMEDIATE CODE ====================
                            backendManager.generateC3DInst(
                                opCodeConditional
                                , new Operator(symbolOpBooleanVal1.idVariable + "", TypeOperator.variable)
                                , null
                                , new Operator(symbolOpBooleanVal1.idLabel + "", TypeOperator.label)
                            );

                            backendManager.generateC3DInst(
                                opCodeVariable
                                , new Operator(symbolOpBoolVal2.idVariable + "", TypeOperator.variable)
                                , null
                                , new Operator(symbolOpBooleanVal1.idVariable + "", TypeOperator.variable)
                            );

                            symbolOpBoolean.idLabel = symbolOpBooleanVal1.idLabel;
                            symbolOpBoolean.idVariable = symbolOpBooleanVal1.idVariable;
                            symbolOpBoolean.indexQuadruples = backendManager.getSizeOfC3DList();
                            symbolOpBoolean.isSingleBoolean = false;
                            
                        // ===========================================================

                        RESULT = symbolOpBoolean;
                    
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("OP_BOOLEAN",23, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 38: // OP_BOOLEAN ::= OP_BOOL_VALUE 
            {
              SymbolOpBoolean RESULT =null;
		int op_bool_valueleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int op_bool_valueright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		SymbolOpBoolValue op_bool_value = (SymbolOpBoolValue)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                        // ============== GENERATE NODE FOR DIGRAPH ==============
                        String description ="[OP_BOOLEAN => OP_BOOL_VALUE]";

                        ArrayList<NodeGraph.VARIABLES> childs = new ArrayList<NodeGraph.VARIABLES>();
                        childs.add(NodeGraph.VARIABLES.OP_BOOL_VALUE);

                        NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.OP_BOOLEAN);
                        digraph.addNode(nodeGraph, childs);
                        // =======================================================
                        SymbolOpBoolValue symbolOpBoolValue =  op_bool_value;
                        SymbolOpBoolean symbolOpBoolean = new SymbolOpBoolean();

                        // If it is a constant, then we pass the value to the higher node
                        if (symbolOpBoolValue.isConstant) {
                            symbolOpBoolean.isConstant = true;
                            symbolOpBoolean.valueType = symbolOpBoolValue.valueType;
                        }

                        // ==================== INTERMEDIATE CODE ====================
                            int idLabel = backendManager.tablesManager.addLabel();
                            symbolOpBoolean.idVariable = symbolOpBoolValue.idVariable;
                            symbolOpBoolean.idLabel = idLabel + "";
                            symbolOpBoolean.indexQuadruples = backendManager.getSizeOfC3DList();
                            symbolOpBoolean.isSingleBoolean = true;
                        // ===========================================================
                        RESULT = symbolOpBoolean;
                    
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("OP_BOOLEAN",23, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 39: // OP_BOOL_VALUE ::= bool 
            {
              SymbolOpBoolValue RESULT =null;
		int bool_valleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int bool_valright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String bool_val = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 
                        // ============== GENERATE NODE FOR DIGRAPH ==============
                        String description ="[OP_BOOL_VALUE => bool]";

                        NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.OP_BOOL_VALUE);
                        digraph.addNode(nodeGraph);
                        // =======================================================
                        Boolean boolVal = new Boolean(bool_val);
                         
                        SymbolOpBoolValue symbolOpBoolValue = new SymbolOpBoolValue(boolVal);

                        // ==================== INTERMEDIATE CODE ====================
                            TypeDescription typeBoolean = symbolsTable.query("boolean");
                            int isArgument = 0; // Is not an argument
                            int idVar = backendManager.tablesManager.addTemporalVariable(backendManager.tablesManager.getActualProcedure(), typeBoolean.size, 0, typeBoolean.basicSubjacentType);
                            symbolOpBoolValue.idVariable = idVar + "";
                            backendManager.generateC3DInst(
                                OpCode.assign
                                , new Operator(bool_val, TypeOperator.bool_value)
                                , null
                                , new Operator(idVar + "", TypeOperator.variable)
                            );
                            
                        // ===========================================================
                        RESULT = symbolOpBoolValue;
                    
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("OP_BOOL_VALUE",24, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 40: // OP_BOOL_VALUE ::= lparen OP_BOOLEAN rparen 
            {
              SymbolOpBoolValue RESULT =null;
		int op_booleanleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int op_booleanright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		SymbolOpBoolean op_boolean = (SymbolOpBoolean)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
                        // ============== GENERATE NODE FOR DIGRAPH ==============
                        String description ="[OP_BOOL_VALUE => lparen OP_BOOLEAN rparen]";

                        ArrayList<NodeGraph.VARIABLES> childs = new ArrayList<NodeGraph.VARIABLES>();
                        childs.add(NodeGraph.VARIABLES.OP_BOOLEAN);

                        NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.OP_BOOL_VALUE);
                        digraph.addNode(nodeGraph, childs);
                        // =======================================================
                        SymbolOpBoolean symbolOpBoolean = op_boolean;
                        SymbolOpBoolValue symbolOpBoolValue = new SymbolOpBoolValue();

                        // If it is a constant, then we pass the value to the higher node
                        if(symbolOpBoolean.isConstant) {
                            symbolOpBoolValue.isConstant = true;
                            symbolOpBoolValue.valueType = symbolOpBoolean.valueType;
                        }
                        /*
                        Quadruple quadruple = new Quadruple(OP_CODE.skip, "", "", symbolOpBoolean.idLabel);
                        quadruples.add(quadruple);

                        symbolOpBoolValue.idVariable = symbolOpBoolean.idVariable;
                        */
                        backendManager.generateC3DInst(
                                OpCode.skip
                                , null
                                , null
                                , new Operator(symbolOpBoolean.idLabel + "", TypeOperator.variable)
                            );
                        symbolOpBoolValue.idVariable = symbolOpBoolean.idVariable;
                        RESULT = symbolOpBoolValue;
                    
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("OP_BOOL_VALUE",24, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 41: // OP_BOOL_VALUE ::= id 
            {
              SymbolOpBoolValue RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                        // ============== GENERATE NODE FOR DIGRAPH ==============
                        String description ="[OP_BOOL_VALUE => id]";

                        NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.OP_BOOL_VALUE);
                        digraph.addNode(nodeGraph);
                        // =======================================================

                        TypeDescription typeDescription = symbolsTable.query(id);
                        if (typeDescription.contentDescription != CONTENT_DESCRIPTION.dvar 
                            && typeDescription.contentDescription != CONTENT_DESCRIPTION.dconst 
                            && typeDescription.contentDescription != CONTENT_DESCRIPTION.darg) {
                                throw new IncorrectTypeException(
                                    CompilerException.CompilerErrorType.semantic,
                                    "Error in boolean operation. The value has an incorrect content description: " + typeDescription.contentDescription + "."
                                );
                        }
                        TypeDescription typeDescriptionType = symbolsTable.query(typeDescription.nameType);
                        if (typeDescriptionType.basicSubjacentType != BASIC_SUBJACENT_TYPE.ts_boolean) {
                            throw new IncorrectTypeException(
                                    CompilerException.CompilerErrorType.semantic,
                                    "Error in boolean operation. The value has an incorrect subjacent type: " + typeDescriptionType.basicSubjacentType + "."
                            );
                        }

                        SymbolOpBoolValue symbolOpBoolValue = new SymbolOpBoolValue();
                        // If it is a constant, then we pass the value to the higher node
                        if (typeDescription.contentDescription == CONTENT_DESCRIPTION.dconst) {
                            symbolOpBoolValue.isConstant = true;
                            symbolOpBoolValue.valueType = typeDescription.value;
                        }

                        symbolOpBoolValue.idVariable = typeDescription.idBackend + "";

                        RESULT = symbolOpBoolValue; 
                    
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("OP_BOOL_VALUE",24, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 42: // OP_BOOL_VALUE ::= RELATIONAL_COMP 
            {
              SymbolOpBoolValue RESULT =null;
		int relational_compleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int relational_compright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		SymbolRelationalComp relational_comp = (SymbolRelationalComp)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                        // ============== GENERATE NODE FOR DIGRAPH ==============
                        String description ="[OP_BOOL_VALUE => RELATIONAL_COMP]";

                        ArrayList<NodeGraph.VARIABLES> childs = new ArrayList<NodeGraph.VARIABLES>();
                        childs.add(NodeGraph.VARIABLES.RELATIONAL_COMP);

                        NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.OP_BOOL_VALUE);
                        digraph.addNode(nodeGraph, childs);
                        // =======================================================
                        SymbolRelationalComp symbolRelationalComp = relational_comp;
                        SymbolOpBoolValue symbolOpBoolValue = new SymbolOpBoolValue();
                        symbolOpBoolValue.idVariable = symbolRelationalComp.idVariable;
                        RESULT = symbolOpBoolValue;
                    
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("OP_BOOL_VALUE",24, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 43: // RELATIONAL_COMP ::= lbracket VALUE op_relational VALUE rbracket 
            {
              SymbolRelationalComp RESULT =null;
		int value_1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int value_1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		SymbolValue value_1 = (SymbolValue)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int op_relationalleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int op_relationalright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		String op_relational = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int value_2left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int value_2right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		SymbolValue value_2 = (SymbolValue)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
                        // ============== GENERATE NODE FOR DIGRAPH ==============
                        String description ="[RELATIONAL_COMP => lbracket VALUE op_relational VALUE rbracket]";

                        ArrayList<NodeGraph.VARIABLES> childs = new ArrayList<NodeGraph.VARIABLES>();
                        childs.add(NodeGraph.VARIABLES.VALUE);
                        childs.add(NodeGraph.VARIABLES.VALUE);

                        NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.RELATIONAL_COMP);
                        digraph.addNode(nodeGraph, childs);
                        // =======================================================

                        SymbolValue symbolValue1 = value_1;
                        SymbolValue symbolValue2 = value_2;

                        BASIC_SUBJACENT_TYPE value1SubjacenBasicType = BASIC_SUBJACENT_TYPE.ts_none;
                        BASIC_SUBJACENT_TYPE value2SubjacenBasicType = BASIC_SUBJACENT_TYPE.ts_none;

                        // ===================== CHECK VALUE 1 AND GET HIS SUUBJACENT BASIC TYPE ========================
                        if (symbolValue1.contentDescription == CONTENT_DESCRIPTION.idnull) {
                            value1SubjacenBasicType = symbolValue1.basicSubjacentType;
                            
                        } else if (symbolValue1.contentDescription == CONTENT_DESCRIPTION.dvar
                                || symbolValue1.contentDescription == CONTENT_DESCRIPTION.dconst
                                || symbolValue1.contentDescription == CONTENT_DESCRIPTION.darg
                                || symbolValue1.contentDescription == CONTENT_DESCRIPTION.dfunc
                            ) {
                            TypeDescription typeDescription1 = symbolsTable.query(symbolValue1.nameType);
                            value1SubjacenBasicType = typeDescription1.basicSubjacentType;

                            if (value1SubjacenBasicType == BASIC_SUBJACENT_TYPE.ts_none) {
                                throw new IncorrectTypeException(
                                    CompilerException.CompilerErrorType.semantic,
                                    "Error in relational comparation. The basic subjacent type can't be 'none'."
                                );
                            }

                        } else {
                            throw new IncorrectTypeException(
                                    CompilerException.CompilerErrorType.semantic,
                                    "Error in relational comparation. The value has an incorrect content description: " + symbolValue1.contentDescription + "."
                                );
                        }
                        // =============================================================================================
                        
                        // ===================== CHECK VALUE 2 AND GET HIS SUUBJACENT BASIC TYPE ========================
                        if (symbolValue2.contentDescription == CONTENT_DESCRIPTION.idnull) {
                            value2SubjacenBasicType = symbolValue2.basicSubjacentType;
                            
                        } else if (symbolValue2.contentDescription == CONTENT_DESCRIPTION.dvar
                                || symbolValue2.contentDescription == CONTENT_DESCRIPTION.dconst
                                || symbolValue2.contentDescription == CONTENT_DESCRIPTION.darg
                                || symbolValue2.contentDescription == CONTENT_DESCRIPTION.dfunc
                            ) {
                            TypeDescription typeDescription2 = symbolsTable.query(symbolValue2.nameType);
                            value2SubjacenBasicType = typeDescription2.basicSubjacentType;

                            if (value2SubjacenBasicType == BASIC_SUBJACENT_TYPE.ts_none) {
                                throw new IncorrectTypeException(
                                    CompilerException.CompilerErrorType.semantic,
                                    "Error in relational comparation. The basic subjacent type can't be 'none'."
                                );
                            }

                        } else {
                            throw new IncorrectTypeException(
                                    CompilerException.CompilerErrorType.semantic,
                                    "Error in relational comparation. The value has an incorrect content description: " + symbolValue2.contentDescription + "."
                            );
                        }
                        // =============================================================================================

                        // ====================== CHECK SUBJACENT BASIC TYPES FROM VALUES ==============================
                        if (value1SubjacenBasicType != BASIC_SUBJACENT_TYPE.ts_integer
                            && value1SubjacenBasicType != BASIC_SUBJACENT_TYPE.ts_boolean
                            && value1SubjacenBasicType != BASIC_SUBJACENT_TYPE.ts_string
                            ) {
                            throw new IncorrectTypeException(
                                    CompilerException.CompilerErrorType.semantic,
                                    "Error in relational comparation. One value has an incorrect subjacent basic type: " + value1SubjacenBasicType + "."
                            );
                        }

                        if (value2SubjacenBasicType != BASIC_SUBJACENT_TYPE.ts_integer
                            && value2SubjacenBasicType != BASIC_SUBJACENT_TYPE.ts_boolean
                            && value2SubjacenBasicType != BASIC_SUBJACENT_TYPE.ts_string
                            ) {
                            throw new IncorrectTypeException(
                                    CompilerException.CompilerErrorType.semantic,
                                    "Error in relational comparation. One value has an incorrect subjacent basic type: " + value2SubjacenBasicType + "."
                            );
                        }

                        if (value1SubjacenBasicType != value2SubjacenBasicType) {
                            throw new IncorrectTypeException(
                                    CompilerException.CompilerErrorType.semantic,
                                    "Error in relational comparation. The values has differente subjacent basic types. " 
                                    + "Value 1 has " + value1SubjacenBasicType + " as his subjacent basic type. "
                                    + "Value 1 has " + value2SubjacenBasicType + " as his subjacent basic type. "
                            );
                        }
                        // =============================================================================================

                        if ((op_relational.equals("<")
                            || op_relational.equals("<=")
                            || op_relational.equals(">")
                            || op_relational.equals(">="))
                            && value1SubjacenBasicType != BASIC_SUBJACENT_TYPE.ts_integer
                            ) {
                            throw new IncorrectTypeException(
                                    CompilerException.CompilerErrorType.semantic,
                                    "Error in relational comparation. This relational operator '"
                                    + op_relational 
                                    +"' only compares numbers, not values with this basic subjacent type " 
                                    + value1SubjacenBasicType 
                                    + "."
                            );
                        }

                        SymbolRelationalComp symbolRelationalComp = new SymbolRelationalComp();
                        
                        // If it is a constant, then we pass the value to the higher node
                        if (symbolValue1.isConstant && symbolValue2.isConstant) {
                            Boolean newValue = false;


                            switch(op_relational) {
                                case "==": 
                                    if (value1SubjacenBasicType == BASIC_SUBJACENT_TYPE.ts_integer) {
                                        newValue = (((Integer) symbolValue1.valueType) == ((Integer) symbolValue2.valueType));

                                    } else if (value1SubjacenBasicType == BASIC_SUBJACENT_TYPE.ts_boolean) {
                                        newValue = (((Boolean) symbolValue1.valueType) == ((Boolean) symbolValue2.valueType));

                                    } else if (value1SubjacenBasicType == BASIC_SUBJACENT_TYPE.ts_string) {
                                        newValue = ((String) symbolValue1.valueType).equals((String) symbolValue2.valueType);
                                    }
                                break;

                                case "!=": 
                                    if (value1SubjacenBasicType == BASIC_SUBJACENT_TYPE.ts_integer) {
                                        newValue = (((Integer) symbolValue1.valueType) != ((Integer) symbolValue2.valueType));

                                    } else if (value1SubjacenBasicType == BASIC_SUBJACENT_TYPE.ts_boolean) {
                                        newValue = (((Boolean) symbolValue1.valueType) !=((Boolean) symbolValue2.valueType));

                                    } else if (value1SubjacenBasicType == BASIC_SUBJACENT_TYPE.ts_string) {
                                        newValue = !(((String) symbolValue1.valueType).equals((String) symbolValue2.valueType));
                                    }
                                break;

                                case "<" : newValue = (((Integer) symbolValue1.valueType) <  ((Integer) symbolValue2.valueType)); break;
                                case "<=": newValue = (((Integer) symbolValue1.valueType) <= ((Integer) symbolValue2.valueType)); break;
                                case ">" : newValue = (((Integer) symbolValue1.valueType) >  ((Integer) symbolValue2.valueType)); break;
                                case ">=": newValue = (((Integer) symbolValue1.valueType) >= ((Integer) symbolValue2.valueType)); break;
                            }

                            symbolRelationalComp.isConstant = true;
                            symbolRelationalComp.valueType = newValue;
                        }

                        OpCode opCode = OpCode.equal;
                        switch(op_relational) {
                                case "==": opCode = OpCode.equal; break;
                                case "!=": opCode = OpCode.notEqual; break;
                                case "<" : opCode = OpCode.lower; break;
                                case "<=": opCode = OpCode.lowerOrEqual; break;
                                case ">" : opCode = OpCode.greater; break;
                                case ">=": opCode = OpCode.greaterOrEqual; break;
                        }

                        TypeOperator typeOperator = TypeOperator.int_value;
                        int sizeNewVariable = 4;
                        if (value1SubjacenBasicType == BASIC_SUBJACENT_TYPE.ts_integer) {
                            typeOperator = TypeOperator.int_value;

                        } else if (value1SubjacenBasicType == BASIC_SUBJACENT_TYPE.ts_boolean) {
                            typeOperator = TypeOperator.bool_value;
  
                        }

                        // ==================== INTERMEDIATE CODE ====================
                            TypeDescription typeDescriptionBoolean = symbolsTable.query("boolean");
                            int isArgument = 0; // Is not an argument
                            int idVar = backendManager.tablesManager.addTemporalVariable(backendManager.tablesManager.getActualProcedure(), typeDescriptionBoolean.size, 0, typeDescriptionBoolean.basicSubjacentType);
                            symbolRelationalComp.idVariable = idVar + "";

                            backendManager.generateC3DInst(
                                opCode
                                , new Operator(symbolValue1.idVariable, typeOperator)
                                , new Operator(symbolValue2.idVariable, typeOperator)
                                , new Operator(idVar + "", TypeOperator.variable)
                            );
                            
                        // ===========================================================

                        RESULT = symbolRelationalComp; 

                    
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("RELATIONAL_COMP",25, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 44: // COND ::= INIT_OP_BOOL 
            {
              SymbolCond RESULT =null;
		int init_op_boolleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int init_op_boolright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		SymbolInitOpBool init_op_bool = (SymbolInitOpBool)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                // ============== GENERATE NODE FOR DIGRAPH ==============
                String description ="COND => INIT_OP_BOOL]";

                ArrayList<NodeGraph.VARIABLES> childs = new ArrayList<NodeGraph.VARIABLES>();
                childs.add(NodeGraph.VARIABLES.INIT_OP_BOOL);

                NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.COND);
                digraph.addNode(nodeGraph, childs);
                // =======================================================

                SymbolInitOpBool symbolInitOpBool = init_op_bool;

                // ================ INTERMEDIATE CODE ======================
                    int idLabelTrueCond = backendManager.tablesManager.addLabel();
                    int idLabelFalseCond = backendManager.tablesManager.addLabel();

                    stackTrueCond.push(idLabelTrueCond + "");
                    stackFalseCond.push(idLabelFalseCond + "");

                    backendManager.generateC3DInst(
                        OpCode.condTrue
                        , new Operator(symbolInitOpBool.idVariable, TypeOperator.variable)
                        , null
                        , new Operator(idLabelTrueCond + "", TypeOperator.label)
                    );

                    backendManager.generateC3DInst(
                        OpCode.condFalse
                        , new Operator(symbolInitOpBool.idVariable, TypeOperator.variable)
                        , null
                        , new Operator(idLabelFalseCond + "", TypeOperator.label)
                    );
                // =========================================================

                RESULT = new SymbolCond();
            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("COND",9, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 45: // COND_TRUE_MASK ::= 
            {
              SymbolCondTrueMask RESULT =null;
		
                        // ============== GENERATE NODE FOR DIGRAPH ==============
                        String description ="COND_TRUE_MASK => lambda]";

                        NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.COND_TRUE_MASK);
                        digraph.addNode(nodeGraph);
                        // =======================================================

                        // ================ INTERMEDIATE CODE ======================
                            String trueCondLabel = stackTrueCond.pop();
                            backendManager.generateC3DInst(
                                OpCode.skip
                                , null
                                , null
                                , new Operator(trueCondLabel, TypeOperator.label)
                            );
                        // =========================================================

                        RESULT = new SymbolCondTrueMask();
                    
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("COND_TRUE_MASK",10, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 46: // COND_FALSE_MASK ::= 
            {
              SymbolCondFalseMask RESULT =null;
		
                        // ============== GENERATE NODE FOR DIGRAPH ==============
                        String description ="COND_FALSE_MASK => lambda]";

                        NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.COND_FALSE_MASK);
                        digraph.addNode(nodeGraph);
                        // =======================================================

                        // ================ INTERMEDIATE CODE ======================
                            String falseCondLabel = stackFalseCond.pop();
                            backendManager.generateC3DInst(
                                OpCode.skip
                                , null
                                , null
                                , new Operator(falseCondLabel, TypeOperator.label)
                            );
                        // =========================================================
                        RESULT = new SymbolCondFalseMask();
                    
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("COND_FALSE_MASK",11, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 47: // JUMP_LABEL ::= USELESS 
            {
              SymbolJumpLabel RESULT =null;
		

            // ================ INTERMEDIATE CODE ======================
                int idLabel = backendManager.tablesManager.addLabel();

                backendManager.generateC3DInst(
                    OpCode.jump
                    , null
                    , null
                    , new Operator(idLabel + "", TypeOperator.label)
                );
            // =========================================================

            RESULT = new SymbolJumpLabel(idLabel + "");
        
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("JUMP_LABEL",12, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 48: // SKIP_LABEL ::= USELESS 
            {
              SymbolSkipLabel RESULT =null;
		
            // ================ INTERMEDIATE CODE ======================
                int idLabel = backendManager.tablesManager.addLabel();

                backendManager.generateC3DInst(
                    OpCode.skip
                    , null
                    , null
                    , new Operator(idLabel + "", TypeOperator.label)
                );
            // =========================================================
            RESULT = new SymbolSkipLabel(idLabel + "");
        
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("SKIP_LABEL",13, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 49: // COND_IF ::= inst_if COND lbracket CODE_BLOCK_IN COND_TRUE_MASK INSTRS CODE_BLOCK_OUT rbracket COND_ELIF COND_ELSE 
            {
              SymbolCondIf RESULT =null;
		
                // ============== GENERATE NODE FOR DIGRAPH ==============
                String description ="[COND_IF => inst_if COND lbracket CODE_BLOCK_IN COND_TRUE_MASK INSTRS CODE_BLOCK_OUT rbracket COND_ELIF COND_ELSE]";

                ArrayList<NodeGraph.VARIABLES> childs = new ArrayList<NodeGraph.VARIABLES>();
                childs.add(NodeGraph.VARIABLES.COND);
                childs.add(NodeGraph.VARIABLES.CODE_BLOCK_IN);
                childs.add(NodeGraph.VARIABLES.COND_TRUE_MASK);
                childs.add(NodeGraph.VARIABLES.INSTRS);
                childs.add(NodeGraph.VARIABLES.CODE_BLOCK_OUT);
                childs.add(NodeGraph.VARIABLES.COND_ELIF);
                childs.add(NodeGraph.VARIABLES.COND_ELSE);

                NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.COND_IF);
                digraph.addNode(nodeGraph, childs);
                // =======================================================

                RESULT = new SymbolCondIf();
            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("COND_IF",14, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-9)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 50: // COND_ELIF ::= COND_ELIF JUMP_LABEL inst_elif COND_FALSE_MASK COND lbracket CODE_BLOCK_IN COND_TRUE_MASK INSTRS CODE_BLOCK_OUT rbracket 
            {
              SymbolCondElif RESULT =null;
		int jump_labelleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-9)).left;
		int jump_labelright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-9)).right;
		SymbolJumpLabel jump_label = (SymbolJumpLabel)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-9)).value;
		
                    // ============== GENERATE NODE FOR DIGRAPH ==============
                    String description ="[COND_ELIF => COND_ELIF inst_elif COND_FALSE_MASK COND lbracket CODE_BLOCK_IN INSTRS CODE_BLOCK_OUT rbracket]";

                    ArrayList<NodeGraph.VARIABLES> childs = new ArrayList<NodeGraph.VARIABLES>();
                    childs.add(NodeGraph.VARIABLES.COND_ELIF);
                    childs.add(NodeGraph.VARIABLES.COND_FALSE_MASK);
                    childs.add(NodeGraph.VARIABLES.COND);
                    childs.add(NodeGraph.VARIABLES.CODE_BLOCK_IN);
                    childs.add(NodeGraph.VARIABLES.INSTRS);
                    childs.add(NodeGraph.VARIABLES.CODE_BLOCK_OUT);

                    NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.COND_ELIF);
                    digraph.addNode(nodeGraph, childs);
                    // =======================================================

                    // ================ INTERMEDIATE CODE ======================
                        backendManager.generateC3DInst(
                            OpCode.skip
                            , null
                            , null
                            , new Operator(jump_label.idLabel, TypeOperator.label)
                        );
                    // =========================================================
                    RESULT = new SymbolCondElif();
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("COND_ELIF",15, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-10)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 51: // COND_ELIF ::= 
            {
              SymbolCondElif RESULT =null;
		
                    // ============== GENERATE NODE FOR DIGRAPH ==============
                    String description ="[COND_ELIF => lambda]";

                    NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.COND_ELIF);
                    digraph.addNode(nodeGraph);
                    // =======================================================

                    RESULT = new SymbolCondElif();
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("COND_ELIF",15, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 52: // COND_ELSE ::= JUMP_LABEL inst_else lbracket CODE_BLOCK_IN COND_FALSE_MASK INSTRS CODE_BLOCK_OUT rbracket 
            {
              SymbolCondElse RESULT =null;
		int jump_labelleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-7)).left;
		int jump_labelright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-7)).right;
		SymbolJumpLabel jump_label = (SymbolJumpLabel)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-7)).value;
		
                    // ============== GENERATE NODE FOR DIGRAPH ==============
                    String description ="[COND_ELSE => inst_else lbracket COND_FALSE_MASK CODE_BLOCK_IN INSTRS CODE_BLOCK_OUT rbracket]";

                    ArrayList<NodeGraph.VARIABLES> childs = new ArrayList<NodeGraph.VARIABLES>();
                    childs.add(NodeGraph.VARIABLES.CODE_BLOCK_IN);
                    childs.add(NodeGraph.VARIABLES.COND_FALSE_MASK);
                    childs.add(NodeGraph.VARIABLES.INSTRS);
                    childs.add(NodeGraph.VARIABLES.CODE_BLOCK_OUT);

                    NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.COND_ELSE);
                    digraph.addNode(nodeGraph, childs);
                    // =======================================================

                    // ================ INTERMEDIATE CODE ======================
                        backendManager.generateC3DInst(
                            OpCode.skip
                            , null
                            , null
                            , new Operator(jump_label.idLabel, TypeOperator.label)
                        );
                    // =========================================================
                    RESULT = new SymbolCondElse();
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("COND_ELSE",16, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-7)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 53: // COND_ELSE ::= COND_FALSE_MASK 
            {
              SymbolCondElse RESULT =null;
		
                    // ============== GENERATE NODE FOR DIGRAPH ==============
                    String description ="[COND_ELSE => COND_FALSE_MASK]";

                    ArrayList<NodeGraph.VARIABLES> childs = new ArrayList<NodeGraph.VARIABLES>();
                    childs.add(NodeGraph.VARIABLES.COND_FALSE_MASK);
                    NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.COND_ELSE);
                    digraph.addNode(nodeGraph, childs);
                    // =======================================================

                    RESULT = new SymbolCondElse();
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("COND_ELSE",16, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 54: // SWITCH ::= SWITCH_BEGIN SWITCH_END 
            {
              SymbolSwitch RESULT =null;
		
                // ============== GENERATE NODE FOR DIGRAPH ==============
                String description ="[SWITCH => SWITCH_BEGIN SWITCH_END]";

                ArrayList<NodeGraph.VARIABLES> childs = new ArrayList<NodeGraph.VARIABLES>();
                childs.add(NodeGraph.VARIABLES.SWITCH_BEGIN);
                childs.add(NodeGraph.VARIABLES.SWITCH_END);

                NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.SWITCH);
                digraph.addNode(nodeGraph, childs);
                // =======================================================

                RESULT = new SymbolSwitch();
            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("SWITCH",17, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 55: // SWITCH_BEGIN ::= SWITCH_BEGIN inst_case lparen VALUE rparen two_points CODE_BLOCK_IN INSTRS CODE_BLOCK_OUT inst_break final_sentence 
            {
              SymbolSwitchBegin RESULT =null;
		int switch_beginleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-10)).left;
		int switch_beginright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-10)).right;
		SymbolSwitchBegin switch_begin = (SymbolSwitchBegin)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-10)).value;
		int comparison_valueleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-7)).left;
		int comparison_valueright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-7)).right;
		SymbolValue comparison_value = (SymbolValue)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-7)).value;
		
                        // ============== GENERATE NODE FOR DIGRAPH ==============
                        String description ="[SWITCH_BEGIN => SWITCH_BEGIN inst_case lparen VALUE rparen two_points CODE_BLOCK_IN INSTRS CODE_BLOCK_OUT inst_break final_sentence]";

                        ArrayList<NodeGraph.VARIABLES> childs = new ArrayList<NodeGraph.VARIABLES>();
                        childs.add(NodeGraph.VARIABLES.SWITCH_BEGIN);
                        childs.add(NodeGraph.VARIABLES.VALUE);
                        childs.add(NodeGraph.VARIABLES.CODE_BLOCK_IN);
                        childs.add(NodeGraph.VARIABLES.INSTRS);
                        childs.add(NodeGraph.VARIABLES.CODE_BLOCK_OUT);

                        NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.SWITCH_BEGIN);
                        digraph.addNode(nodeGraph, childs);
                        // =======================================================
                        SymbolSwitchBegin symbolSwitchBegin = switch_begin;
                        SymbolValue symbolValue = comparison_value;
                        BASIC_SUBJACENT_TYPE caseBasicSubjacentType = BASIC_SUBJACENT_TYPE.ts_none;

                        if (symbolValue.contentDescription == CONTENT_DESCRIPTION.idnull) {
                            caseBasicSubjacentType = symbolValue.basicSubjacentType;

                        }else if (symbolValue.contentDescription == CONTENT_DESCRIPTION.dvar
                                    || symbolValue.contentDescription == CONTENT_DESCRIPTION.dconst
                                    || symbolValue.contentDescription == CONTENT_DESCRIPTION.darg
                                ) {
                            TypeDescription typeDescription = symbolsTable.query(symbolValue.nameType);
                            caseBasicSubjacentType = typeDescription.basicSubjacentType;
                        } else {
                            throw new IncorrectTypeException(
                                    CompilerException.CompilerErrorType.semantic,
                                    "Error in switch. The value has an incorrect type: " + symbolValue.contentDescription + "."
                            );
                        }

                        if (symbolSwitchBegin.basicSubjacentType != caseBasicSubjacentType) {
                            throw new IncorrectTypeException(
                                    CompilerException.CompilerErrorType.semantic,
                                    "Error in case. The value of switch and case are different. The basic subjacent type of switch is '" 
                                    + symbolSwitchBegin.basicSubjacentType + "' and the basic subjacent type of case is '" + caseBasicSubjacentType + "'."
                            );
                        }

                        RESULT = symbolSwitchBegin;
                    
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("SWITCH_BEGIN",18, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-10)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 56: // SWITCH_BEGIN ::= inst_switch lparen VALUE rparen lbracket 
            {
              SymbolSwitchBegin RESULT =null;
		int comparison_valueleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int comparison_valueright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		SymbolValue comparison_value = (SymbolValue)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		
                        // ============== GENERATE NODE FOR DIGRAPH ==============
                        String description ="[SWITCH_BEGIN => inst_switch lparen VALUE rparen lbracket]";

                        ArrayList<NodeGraph.VARIABLES> childs = new ArrayList<NodeGraph.VARIABLES>();
                        childs.add(NodeGraph.VARIABLES.VALUE);

                        NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.SWITCH_BEGIN);
                        digraph.addNode(nodeGraph, childs);
                        // =======================================================
                        SymbolValue symbolValue = comparison_value;
                        BASIC_SUBJACENT_TYPE basicSubjacentType = BASIC_SUBJACENT_TYPE.ts_none;

                        if (symbolValue.contentDescription == CONTENT_DESCRIPTION.idnull) {
                            basicSubjacentType = symbolValue.basicSubjacentType;

                        }else if (symbolValue.contentDescription == CONTENT_DESCRIPTION.dvar
                                    || symbolValue.contentDescription == CONTENT_DESCRIPTION.dconst
                                    || symbolValue.contentDescription == CONTENT_DESCRIPTION.darg
                                ) {
                            TypeDescription typeDescription = symbolsTable.query(symbolValue.nameType);
                            basicSubjacentType = typeDescription.basicSubjacentType;
                        } else {
                            throw new IncorrectTypeException(
                                    CompilerException.CompilerErrorType.semantic,
                                    "Error in switch. The value has an incorrect type: " + symbolValue.contentDescription + "."
                            );
                        }

                        RESULT = new SymbolSwitchBegin(basicSubjacentType);
                    
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("SWITCH_BEGIN",18, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 57: // SWITCH_END ::= inst_default two_points CODE_BLOCK_IN INSTRS CODE_BLOCK_OUT inst_break final_sentence rbracket 
            {
              SymbolSwitchEnd RESULT =null;
		
                    // ============== GENERATE NODE FOR DIGRAPH ==============
                    String description ="[SWITCH_END => inst_default two_points CODE_BLOCK_IN INSTRS CODE_BLOCK_OUT rbracket]";

                    ArrayList<NodeGraph.VARIABLES> childs = new ArrayList<NodeGraph.VARIABLES>();
                    childs.add(NodeGraph.VARIABLES.CODE_BLOCK_IN);
                    childs.add(NodeGraph.VARIABLES.INSTRS);
                    childs.add(NodeGraph.VARIABLES.CODE_BLOCK_OUT);

                    NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.SWITCH_END);
                    digraph.addNode(nodeGraph, childs);
                    // =======================================================

                    RESULT = new SymbolSwitchEnd();
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("SWITCH_END",19, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-7)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 58: // SWITCH_END ::= rbracket 
            {
              SymbolSwitchEnd RESULT =null;
		
                    // ============== GENERATE NODE FOR DIGRAPH ==============
                    String description ="[SWITCH_END => lambda]";

                    NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.SWITCH_END);
                    digraph.addNode(nodeGraph);
                    // =======================================================

                    RESULT = new SymbolSwitchEnd();
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("SWITCH_END",19, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 59: // WHILE ::= inst_while SKIP_LABEL COND lbracket CODE_BLOCK_IN COND_TRUE_MASK INSTRS CODE_BLOCK_OUT rbracket 
            {
              SymbolWhile RESULT =null;
		int skip_labelleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-7)).left;
		int skip_labelright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-7)).right;
		SymbolSkipLabel skip_label = (SymbolSkipLabel)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-7)).value;
		
                // ============== GENERATE NODE FOR DIGRAPH ==============
                String description ="[WHILE => inst_while  INIT_OP_BOOL lbracket CODE_BLOCK_IN INSTRS CODE_BLOCK_OUT rbracket]";

                ArrayList<NodeGraph.VARIABLES> childs = new ArrayList<NodeGraph.VARIABLES>();
                childs.add(NodeGraph.VARIABLES.INIT_OP_BOOL);
                childs.add(NodeGraph.VARIABLES.CODE_BLOCK_IN);
                childs.add(NodeGraph.VARIABLES.INSTRS);
                childs.add(NodeGraph.VARIABLES.CODE_BLOCK_OUT);

                NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.WHILE);
                digraph.addNode(nodeGraph, childs);
                // =======================================================

                // ================ INTERMEDIATE CODE ======================
                    String falseCondLabel = stackFalseCond.pop();

                    backendManager.generateC3DInst(
                        OpCode.jump
                        , null
                        , null
                        , new Operator(skip_label.idLabel, TypeOperator.label)
                    );

                    backendManager.generateC3DInst(
                        OpCode.skip
                        , null
                        , null
                        , new Operator(falseCondLabel, TypeOperator.label)
                    );
                // =========================================================
                RESULT = new SymbolWhile();
            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("WHILE",39, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-8)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 60: // FOR ::= inst_for CODE_BLOCK_IN lparen DECLS INIT_OP_BOOL final_sentence ASSIGN rparen lbracket INSTRS CODE_BLOCK_OUT rbracket 
            {
              SymbolFor RESULT =null;
		
                // ============== GENERATE NODE FOR DIGRAPH ==============
                String description ="[FOR => inst_for CODE_BLOCK_IN lparen DECLS two_points INIT_OP_BOOL two_points ASSIGN rparen lbracket INSTRS CODE_BLOCK_OUT rbracket]";

                ArrayList<NodeGraph.VARIABLES> childs = new ArrayList<NodeGraph.VARIABLES>();
                childs.add(NodeGraph.VARIABLES.CODE_BLOCK_IN);
                childs.add(NodeGraph.VARIABLES.DECLS);
                childs.add(NodeGraph.VARIABLES.INIT_OP_BOOL);
                childs.add(NodeGraph.VARIABLES.ASSIGN);
                childs.add(NodeGraph.VARIABLES.INSTRS);
                childs.add(NodeGraph.VARIABLES.CODE_BLOCK_OUT);

                NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.FOR);
                digraph.addNode(nodeGraph, childs);
                // =======================================================

                RESULT = new SymbolFor();
            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("FOR",40, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-11)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 61: // CODE_BLOCK_IN ::= 
            {
              SymbolCodeBlockIn RESULT =null;
		
                        // ============== GENERATE NODE FOR DIGRAPH ==============
                        String description ="[CODE_BLOCK_IN => lambda]";

                        NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.CODE_BLOCK_IN);
                        digraph.addNode(nodeGraph);
                        // =======================================================

                        symbolsTable.getinBlock();
                        RESULT = new SymbolCodeBlockIn();
                    
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("CODE_BLOCK_IN",20, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 62: // CODE_BLOCK_OUT ::= 
            {
              SymbolCodeBlockOut RESULT =null;
		  
                        // ============== GENERATE NODE FOR DIGRAPH ==============
                        String description ="[CODE_BLOCK_OUT => lambda]";

                        NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.CODE_BLOCK_OUT);
                        digraph.addNode(nodeGraph);
                        // =======================================================

                        symbolsTable.getoutBlock();
                        RESULT = new SymbolCodeBlockOut();
                    
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("CODE_BLOCK_OUT",21, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 63: // FUNCTION ::= FUNCTION FUNC_HEAD rparen lbracket CODE_BLOCK_IN FUNC_BODY RETURN CODE_BLOCK_OUT rbracket 
            {
              SymbolFunction RESULT =null;
		int func_headleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-7)).left;
		int func_headright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-7)).right;
		SymbolFuncHead func_head = (SymbolFuncHead)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-7)).value;
		int return_valleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int return_valright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		SymbolReturn return_val = (SymbolReturn)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		
                // ============== GENERATE NODE FOR DIGRAPH ==============
                String description ="[FUNCTION => FUNC_HEAD rparen lbracket CODE_BLOCK_IN INSTRS RETURN CODE_BLOCK_OUT rbracket]";

                ArrayList<NodeGraph.VARIABLES> childs = new ArrayList<NodeGraph.VARIABLES>();
                childs.add(NodeGraph.VARIABLES.FUNC_HEAD);
                childs.add(NodeGraph.VARIABLES.CODE_BLOCK_IN);
                childs.add(NodeGraph.VARIABLES.FUNC_BODY);
                childs.add(NodeGraph.VARIABLES.RETURN);
                childs.add(NodeGraph.VARIABLES.CODE_BLOCK_OUT);

                NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.FUNCTION);
                digraph.addNode(nodeGraph, childs);
                // =======================================================

                SymbolFuncHead symbolFuncHead = func_head;
                SymbolReturn symbolReturn = return_val;
                TypeDescription typeDescription = symbolsTable.query(symbolFuncHead.nameType);

                if (symbolReturn == null) {
                    if (typeDescription.basicSubjacentType != BASIC_SUBJACENT_TYPE.ts_none) {
                        throw new IncorrectTypeException(
                            CompilerException.CompilerErrorType.semantic,
                            "Your function doesn't return a value."
                        );
                    }
                } else if (symbolReturn.basicSubjacentType != typeDescription.basicSubjacentType) {
                    throw new IncorrectTypeException(
                        CompilerException.CompilerErrorType.semantic,
                        "Your function returns an incorrect value."
                    );
                } else {
                    // ================ INTERMEDIATE CODE ======================
                    backendManager.generateC3DInst(
                        OpCode.procedureReturn
                        , new Operator(symbolFuncHead.numProcedure + "", TypeOperator.procedure)
                        , null
                        , new Operator(return_val.idBackend + "", TypeOperator.variable)
                    );
                }

                backendManager.generateC3DInst(
                        OpCode.procedureEnd
                        , null
                        , null
                        , new Operator(symbolFuncHead.numProcedure + "", TypeOperator.procedure)
                );
                // =========================================================

                RESULT = new SymbolFunction();
            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("FUNCTION",31, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-8)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 64: // FUNCTION ::= 
            {
              SymbolFunction RESULT =null;
		

                // ============== GENERATE NODE FOR DIGRAPH ==============
                String description ="[FUNCTION => lambda]";

                NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.FUNCTION);
                digraph.addNode(nodeGraph);
                // =======================================================
                RESULT = new SymbolFunction();
            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("FUNCTION",31, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 65: // FUNC_HEAD ::= inst_function id id lparen PARAMS 
            {
              SymbolFuncHead RESULT =null;
		int type_variableleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int type_variableright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		String type_variable = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int id_functionleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int id_functionright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		String id_function = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int paramsleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int paramsright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		SymbolParams params = (SymbolParams)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                    // ============== GENERATE NODE FOR DIGRAPH ==============
                    String description ="[FUNC_HEAD => inst_function id id lparen PARAMS]";

                    ArrayList<NodeGraph.VARIABLES> childs = new ArrayList<NodeGraph.VARIABLES>();
                    childs.add(NodeGraph.VARIABLES.PARAMS);

                    NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.FUNC_HEAD);
                    digraph.addNode(nodeGraph, childs);
                    // =======================================================

                    // ================ CHECK IF TYPE IS CORRECT =========================================================
                    TypeDescription typeDescription = symbolsTable.query((String) type_variable);

                    if (typeDescription.contentDescription != TypeDescription.CONTENT_DESCRIPTION.dtype) {
                        throw new IncorrectTypeException(
                            CompilerException.CompilerErrorType.semantic,
                            "Must be a correct type."
                        );
                    }

                    if (!   (typeDescription.basicSubjacentType == TypeDescription.BASIC_SUBJACENT_TYPE.ts_integer
                                || typeDescription.basicSubjacentType == TypeDescription.BASIC_SUBJACENT_TYPE.ts_boolean
                                || typeDescription.basicSubjacentType == TypeDescription.BASIC_SUBJACENT_TYPE.ts_string
                                || typeDescription.basicSubjacentType == TypeDescription.BASIC_SUBJACENT_TYPE.ts_none
                            )
                        ) { 
                        throw new IncorrectTypeException(
                            CompilerException.CompilerErrorType.semantic,
                            "Type of variable must have a correct subjacent type."
                        ); 
                    }
                    // ==================================================================================================

                    // ============= ADD OUR FUNCTION TO DESCRIPTION TABLE ==============================================
                    TypeDescription functionTypeDescription = new TypeDescription(
                        CONTENT_DESCRIPTION.dfunc,
                        type_variable
                    );

                    // ================ INTERMEDIATE CODE ======================
                        int numProcedure = backendManager.tablesManager.addProcedure(
                                id_function, 
                                symbolsTable.currentScope, 
                                0, 
                                typeDescription.size, 
                                typeDescription.basicSubjacentType
                        );
                        functionTypeDescription.idBackend = numProcedure;
                    // =========================================================

                    symbolsTable.add(id_function, functionTypeDescription);
                    // ==================================================================================================

                    // ============= ADD PARAMS OF OUR FUNCTION TO EXPANSION TABLE ======================================
                    SymbolParams symbolParams = params;

                    ArrayList<String> listVariableIds = new ArrayList<String>();
                    ArrayList<TypeDescription> listVariableTypeDescription = new ArrayList<TypeDescription>();

                    if (symbolParams != null) {
                        listVariableIds = symbolParams.listVariableIds;
                        listVariableTypeDescription = symbolParams.listVariableTypeDescription;

                    }

                    for (int i = 0; i < listVariableIds.size(); i++) {
                        TypeDescription typeDescriptionParam = symbolsTable.query(listVariableTypeDescription.get(i).nameType);
                        // ================ INTERMEDIATE CODE ======================
                        int isArgument = -1; // Is an argument
                        int idVar = backendManager.tablesManager.addVariable(listVariableIds.get(i), backendManager.tablesManager.getActualProcedure(),  typeDescriptionParam.size, isArgument,  typeDescriptionParam.basicSubjacentType);
                        
                        // =========================================================
                        TypeDescription typeDescriptionVariable = listVariableTypeDescription.get(i);
                        typeDescriptionVariable.idBackend = idVar;
                        symbolsTable.addParam(id_function, listVariableIds.get(i), typeDescriptionVariable);
                        
                    }
                    // ==================================================================================================

                    // ================ INTERMEDIATE CODE ======================
                    backendManager.generateC3DInst(
                            OpCode.procedureName
                            , null
                            , null
                            , new Operator(numProcedure + "", TypeOperator.procedure)
                    );

                    backendManager.generateC3DInst(
                            OpCode.procedurePreamble
                            , null
                            , null
                            , new Operator(numProcedure + "", TypeOperator.procedure)
                    );
                    // =========================================================

                    RESULT = new SymbolFuncHead(id_function, type_variable, numProcedure);
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("FUNC_HEAD",32, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 66: // PARAMS ::= HAS_PARAMS 
            {
              SymbolParams RESULT =null;
		int has_paramsleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int has_paramsright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		SymbolHasParams has_params = (SymbolHasParams)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                // ============== GENERATE NODE FOR DIGRAPH ==============
                String description ="[PARAMS => HAS_PARAMS]";

                ArrayList<NodeGraph.VARIABLES> childs = new ArrayList<NodeGraph.VARIABLES>();
                childs.add(NodeGraph.VARIABLES.HAS_PARAMS);

                NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.PARAMS);
                digraph.addNode(nodeGraph, childs);
                // =======================================================

                SymbolHasParams symbolHasParams = has_params;

                RESULT = new SymbolParams(symbolHasParams.listVariableIds, symbolHasParams.listVariableTypeDescription);
            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("PARAMS",33, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 67: // PARAMS ::= 
            {
              SymbolParams RESULT =null;
		
                // ============== GENERATE NODE FOR DIGRAPH ==============
                String description ="[PARAMS => lambda]";

                NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.PARAMS);
                digraph.addNode(nodeGraph);
                // =======================================================

                RESULT = new SymbolParams();
            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("PARAMS",33, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 68: // HAS_PARAMS ::= HAS_PARAMS separator id two_points id 
            {
              SymbolHasParams RESULT =null;
		int has_paramsleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).left;
		int has_paramsright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).right;
		SymbolHasParams has_params = (SymbolHasParams)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-4)).value;
		int id_variableleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int id_variableright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		String id_variable = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int type_variableleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int type_variableright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String type_variable = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                    // ============== GENERATE NODE FOR DIGRAPH ==============
                    String description ="[HAS_PARAMS => HAS_PARAMS separator id two_points id]";

                    ArrayList<NodeGraph.VARIABLES> childs = new ArrayList<NodeGraph.VARIABLES>();
                    childs.add(NodeGraph.VARIABLES.HAS_PARAMS);

                    NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.HAS_PARAMS);
                    digraph.addNode(nodeGraph, childs);
                    // =======================================================


                    // ================ CHECK IF TYPE IS CORRECT =============================================================
                    TypeDescription typeDescription = symbolsTable.query((String) type_variable);

                    if (typeDescription.contentDescription != TypeDescription.CONTENT_DESCRIPTION.dtype) {
                        throw new IncorrectTypeException(
                            CompilerException.CompilerErrorType.semantic,
                            "Error in parameters of function. Must be a correct type."
                        );
                    }

                    if (!   (typeDescription.basicSubjacentType == TypeDescription.BASIC_SUBJACENT_TYPE.ts_integer
                                || typeDescription.basicSubjacentType == TypeDescription.BASIC_SUBJACENT_TYPE.ts_boolean
                                || typeDescription.basicSubjacentType == TypeDescription.BASIC_SUBJACENT_TYPE.ts_string
                            )
                        ) { 
                        throw new IncorrectTypeException(
                            CompilerException.CompilerErrorType.semantic,
                            "Error in parameters of function. Type of variable must have a correct subjacent type."
                        ); 
                    }
                    // =======================================================================================================
                    
                    SymbolHasParams symbolHasParams = has_params;
                    ArrayList<String> listVariableIds = symbolHasParams.listVariableIds;
                    ArrayList<TypeDescription> listVariableTypeDescription = symbolHasParams.listVariableTypeDescription;

                    TypeDescription argumentTypeDescription = new TypeDescription(
                        CONTENT_DESCRIPTION.darg,
                        type_variable
                    );

                    listVariableIds.add(id_variable);
                    listVariableTypeDescription.add(argumentTypeDescription);


                    RESULT = new SymbolHasParams(listVariableIds, listVariableTypeDescription);

                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("HAS_PARAMS",34, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 69: // HAS_PARAMS ::= id two_points id 
            {
              SymbolHasParams RESULT =null;
		int id_variableleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int id_variableright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		String id_variable = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int type_variableleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int type_variableright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String type_variable = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                    // ============== GENERATE NODE FOR DIGRAPH ==============
                    String description ="[HAS_PARAMS => id two_points id]";

                    NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.HAS_PARAMS);
                    digraph.addNode(nodeGraph);
                    // =======================================================

                    // ================ CHECK IF TYPE IS CORRECT =============================================================
                    TypeDescription typeDescription = symbolsTable.query((String) type_variable);

                    if (typeDescription.contentDescription != TypeDescription.CONTENT_DESCRIPTION.dtype) {
                        throw new IncorrectTypeException(
                            CompilerException.CompilerErrorType.semantic,
                            "Error in parameters of function. Must be a correct type."
                            );
                    }

                    if (!   (typeDescription.basicSubjacentType == TypeDescription.BASIC_SUBJACENT_TYPE.ts_integer
                                || typeDescription.basicSubjacentType == TypeDescription.BASIC_SUBJACENT_TYPE.ts_boolean
                                || typeDescription.basicSubjacentType == TypeDescription.BASIC_SUBJACENT_TYPE.ts_string
                            )
                        ) { throw new IncorrectTypeException(
                            CompilerException.CompilerErrorType.semantic,
                            "Error in parameters of function. Type of variable must have a correct subjacent type."
                        ); }
                    // =======================================================================================================
                    ArrayList<String> listVariableIds = new ArrayList<String>();
                    ArrayList<TypeDescription> listVariableTypeDescription = new ArrayList<TypeDescription>();

                    TypeDescription argumentTypeDescription = new TypeDescription(
                        CONTENT_DESCRIPTION.darg,
                        type_variable
                    );

                    listVariableIds.add(id_variable);
                    listVariableTypeDescription.add(argumentTypeDescription);


                    RESULT = new SymbolHasParams(listVariableIds, listVariableTypeDescription);
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("HAS_PARAMS",34, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 70: // FUNC_BODY ::= INSTRS 
            {
              SymbolFuncBody RESULT =null;
		
                    // ============== GENERATE NODE FOR DIGRAPH ==============
                    String description ="[FUNC_BODY => INSTRS]";

                    ArrayList<NodeGraph.VARIABLES> childs = new ArrayList<NodeGraph.VARIABLES>();
                    childs.add(NodeGraph.VARIABLES.INSTRS);

                    NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.FUNC_BODY);
                    digraph.addNode(nodeGraph, childs);
                    // =======================================================
                    RESULT = new SymbolFuncBody();
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("FUNC_BODY",35, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 71: // FUNC_BODY ::= 
            {
              SymbolFuncBody RESULT =null;
		
                    // ============== GENERATE NODE FOR DIGRAPH ==============
                    String description ="[FUNC_BODY => lambda]";

                    NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.FUNC_BODY);
                    digraph.addNode(nodeGraph);
                    // =======================================================
                    RESULT = new SymbolFuncBody();
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("FUNC_BODY",35, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 72: // RETURN ::= inst_return VALUE final_sentence 
            {
              SymbolReturn RESULT =null;
		int valleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int valright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		SymbolValue val = (SymbolValue)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
                // ============== GENERATE NODE FOR DIGRAPH ==============
                String description ="[RETURN => inst_return VALUE final_sentence]";

                ArrayList<NodeGraph.VARIABLES> childs = new ArrayList<NodeGraph.VARIABLES>();
                childs.add(NodeGraph.VARIABLES.VALUE);

                NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.RETURN);
                digraph.addNode(nodeGraph, childs);
                // =======================================================

                SymbolValue symbolValue = val;
                BASIC_SUBJACENT_TYPE basicSubjacentType = BASIC_SUBJACENT_TYPE.ts_none;

                if (symbolValue.contentDescription == CONTENT_DESCRIPTION.idnull) {
                    basicSubjacentType = symbolValue.basicSubjacentType;
                } else if (symbolValue.contentDescription == CONTENT_DESCRIPTION.dvar
                    || symbolValue.contentDescription == CONTENT_DESCRIPTION.dconst
                    || symbolValue.contentDescription == CONTENT_DESCRIPTION.darg
                    ) {
                        TypeDescription typeDescription = symbolsTable.query(symbolValue.nameType);
                        basicSubjacentType = typeDescription.basicSubjacentType;
                } else {
                    throw new IncorrectTypeException(
                        CompilerException.CompilerErrorType.semantic,
                        "Error in return instruction. The value has an incorrect content description: " + symbolValue.contentDescription + "."
                    );

                }

                RESULT = new SymbolReturn(symbolValue.idVariable, basicSubjacentType, symbolValue.idVariable);
            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("RETURN",36, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 73: // RETURN ::= 
            {
              SymbolReturn RESULT =null;
		
                // ============== GENERATE NODE FOR DIGRAPH ==============
                String description ="[RETURN => lambda]";

                NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.RETURN);
                digraph.addNode(nodeGraph);
                // =======================================================

                RESULT = new SymbolReturn();
            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("RETURN",36, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 74: // CALL ::= inst_call lparen CALL_BODY rparen 
            {
              SymbolCall RESULT =null;
		int call_bodyleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int call_bodyright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		SymbolCallBody call_body = (SymbolCallBody)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
            // ============== GENERATE NODE FOR DIGRAPH ==============
            String description ="[CALL => inst_call lparen CALL_BODY rparen final_sentence]";

            ArrayList<NodeGraph.VARIABLES> childs = new ArrayList<NodeGraph.VARIABLES>();
            childs.add(NodeGraph.VARIABLES.CALL_BODY);

            NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.CALL);
            digraph.addNode(nodeGraph, childs);
            // =======================================================

            SymbolCallBody symbolCallBody = call_body;

            int numParamsCall = symbolCallBody.counter;
            int numParamsOurFunction = symbolsTable.getNumParameters(symbolCallBody.idFunction);
            
            if (numParamsCall != numParamsOurFunction) {
                throw new IncorrectTypeException(
                    CompilerException.CompilerErrorType.semantic,
                    "Error in call instruction. The number of parameters of the function '" + symbolCallBody.idFunction + "' and the call's instruction are not the same!!"
                );

            }
            backendManager.tablesManager.updateNumParametersInProcedure(symbolCallBody.idBackend, symbolCallBody.counter);
            // ================ INTERMEDIATE CODE ======================
            backendManager.generateC3DInst(
                OpCode.procedureCall
                , null
                , null
                , new Operator(symbolCallBody.idBackend + "", TypeOperator.procedure)
            );
            // =========================================================

            RESULT = new SymbolCall(symbolCallBody.idFunction, symbolCallBody.idBackend);
        
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("CALL",37, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 75: // CALL_BODY ::= CALL_BODY separator VALUE 
            {
              SymbolCallBody RESULT =null;
		int call_paramsleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int call_paramsright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		SymbolCallBody call_params = (SymbolCallBody)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int valleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int valright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		SymbolValue val = (SymbolValue)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                    // ============== GENERATE NODE FOR DIGRAPH ==============
                    String description ="[CALL_BODY => CALL_BODY separator VALUE]";

                    ArrayList<NodeGraph.VARIABLES> childs = new ArrayList<NodeGraph.VARIABLES>();
                    childs.add(NodeGraph.VARIABLES.CALL_BODY);
                    childs.add(NodeGraph.VARIABLES.VALUE);

                    NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.CALL_BODY);
                    digraph.addNode(nodeGraph, childs);
                    // =======================================================

                    SymbolCallBody symbolCallBody = call_params;
                    SymbolValue symbolValue = val;

                    // =================== GET SUBJACENT BASIC TYPE OF OUR VALUE =========================
                    BASIC_SUBJACENT_TYPE valueBasicSubjacentType = BASIC_SUBJACENT_TYPE.ts_none;

                    if (symbolValue.contentDescription == CONTENT_DESCRIPTION.idnull) {
                        valueBasicSubjacentType = symbolValue.basicSubjacentType;
                    } else if (symbolValue.contentDescription == CONTENT_DESCRIPTION.dvar
                        || symbolValue.contentDescription == CONTENT_DESCRIPTION.dconst
                        || symbolValue.contentDescription == CONTENT_DESCRIPTION.darg
                        ) {
                            TypeDescription typeDescription = symbolsTable.query(symbolValue.nameType);
                            valueBasicSubjacentType = typeDescription.basicSubjacentType;
                    } else{
                        throw new IncorrectTypeException(
                            CompilerException.CompilerErrorType.semantic,
                            "Error in call instruction with function id '" + symbolCallBody.idFunction + "'.The value has an incorrect content description: " + symbolValue.contentDescription + "."
                        );

                    }
                    // ======================================================================================

                    TypeDescription parameterTypeDescription = symbolsTable.queryParam(symbolCallBody.idFunction, symbolCallBody.counter);
                    BASIC_SUBJACENT_TYPE parameterBasicSubjacentType = symbolsTable.query(parameterTypeDescription.nameType).basicSubjacentType;

                    if (parameterBasicSubjacentType != valueBasicSubjacentType) {
                        throw new IncorrectTypeException(
                            CompilerException.CompilerErrorType.semantic,
                            "Error in call instruction with function id '" + symbolCallBody.idFunction + "'. The type of parameter and your value are incorrect."
                        );
                    }

                    // ================ INTERMEDIATE CODE ======================
                    backendManager.generateC3DInst(
                        OpCode.procedureParam
                        , new Operator(symbolValue.idVariable + "", TypeOperator.variable)
                        , new Operator(symbolCallBody.counter + 1 + "", TypeOperator.numParam)
                        , new Operator(symbolCallBody.idBackend + "", TypeOperator.procedure)
                    );
                    // =========================================================

                    RESULT = new SymbolCallBody(symbolCallBody.idFunction, symbolCallBody.counter + 1, symbolCallBody.idBackend);
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("CALL_BODY",38, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 76: // CALL_BODY ::= id 
            {
              SymbolCallBody RESULT =null;
		int id_functionleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int id_functionright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String id_function = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                    // ============== GENERATE NODE FOR DIGRAPH ==============
                    String description ="[CALL_BODY => id]";

                    NodeGraph nodeGraph = new NodeGraph(description, NodeGraph.VARIABLES.CALL_BODY);
                    digraph.addNode(nodeGraph);
                    // =======================================================

                    // Only to know if exists our function
                    symbolsTable.query(id_function);
                    TypeDescription typeDescriptionFunction = symbolsTable.query(id_function);

                    RESULT = new SymbolCallBody(id_function, 0, typeDescriptionFunction.idBackend);
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("CALL_BODY",38, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 77: // USELESS ::= 
            {
              SymbolUseless RESULT =null;
		
            RESULT = new SymbolUseless();
        
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("USELESS",41, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /* . . . . . .*/
          default:
            throw new Exception(
               "Invalid action number "+CUP$Parser$act_num+"found in internal parse table");

        }
    } /* end of method */

  /** Method splitting the generated action code into several parts. */
  public final java_cup.runtime.Symbol CUP$Parser$do_action(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack            CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
              return CUP$Parser$do_action_part00000000(
                               CUP$Parser$act_num,
                               CUP$Parser$parser,
                               CUP$Parser$stack,
                               CUP$Parser$top);
    }
}

}
